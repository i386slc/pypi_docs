# Обзор dataclass-factory

## Требования

* python >= 3.6

Вы можете использовать **dataclass\_factory** с python 3.6 и библиотекой **dataclass**, установленной из **pip**.

Начиная с Python 3.7 он не имеет внешних зависимостей за пределами стандартной библиотеки Python.

## Преимущества

* Для простых случаев не требуются схемы или конфигурация. Просто создайте **Factory** и вызовите методы `load/dump`
* Скорость. Это до 10 раз быстрее, чем **marshmallow** и **dataclasses.asdict**.
* Автоматическое преобразование стиля имени (например, **snake\_case** в **CamelCase**)
* Автоматический пропуск полей «внутреннего использования» (с подчеркиванием в начале)
* Перечисления, типизированные словари, кортежи и списки поддерживаются из коробки.
* Объединения **Union** и опции **Optional** поддерживаются без необходимости их определения в схеме.
* Общие классы данных также могут быть автоматически проанализированы.
* Структуры с циклическими ссылками (например, связанные списки или деревья) также могут быть преобразованы.
* Валидаторы для каждого поля

## Пример

```python
from dataclasses import dataclass
import dataclass_factory

@dataclass
class Book:
    title: str
    price: int
    author: str = "Unknown author"

data = {
    "title": "Fahrenheit 451",
    "price": 100,
}

factory = dataclass_factory.Factory()
# То же, что Book(title="Fahrenheit 451", price=100)
book: Book = factory.load(data, Book)
serialized = factory.dump(book)
```

## Поддерживаемые типы

* числовые типы (**int**, **float**, **Decimal**, **complex**, **Fraction**)
* **bool**
* **str**, **bytearray**, **bytes**
* **List** и общие протоколы, такие как **Iterable**, анализируются как список **list**
* **Tuple**, включая что-то вроде `Tuple[int, ...]` или `Tuple[int, str, int]`
* **Dict**
* **Enum** преобразуется с использованием его значения
* **Optional**
* **Any**, при использовании этого типа преобразование при разборе не выполняется. Но сериализация основана на реальном типе данных
* **Union**
* Типы **Literal**, включая варианты из **typing\_extensions**
* Типы **TypedDict** с проверкой **total**, включая варианты из **typing\_extensions**
* **dataclass** и **NamedTuple**
* Классы данных **Generic**
* Другие стандартные типы, такие как **datetime**, **Path**, **UUID** и **IPV4Address**.
* Пользовательские классы можно анализировать автоматически, используя информацию из их метода `__init__`. Сериализация выполняется путем вызова функции `vars()` и последующей обработки реальных типов данных.
* Или вы можете предоставить собственный парсер/сериализатор
