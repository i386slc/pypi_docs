# Конфигурационный файл

Файл конфигурации Supervisor обычно называется `supervisord.conf`. Он используется как **supervisord**, так и **supervisorctl**. Если какое-либо приложение запускается без параметра **-c** (параметр, который используется для явного указания имени файла конфигурации), приложение будет искать файл с именем `supervisord.conf` в следующих местах в указанном порядке. Он будет использовать первый найденный файл.

1. `../etc/supervisord.conf` (относительно исполняемого файла)
2. `../supervisord.conf` (относительно исполняемого файла)
3. `$CWD/supervisord.conf`
4. `$CWD/etc/supervisord.conf`
5. `/etc/supervisord.conf`
6. `/etc/supervisor/supervisord.conf` (начиная с **Supervisor 3.3.0**)

{% hint style="info" %}
Многие версии **Supervisor**, упакованные для **Debian** и **Ubuntu**, включали патч, который добавлял `/etc/supervisor/supervisord.conf` к путям поиска. Первым пакетом PyPI Supervisor, который включал его, был **Supervisor 3.3.0**.
{% endhint %}

## Формат файла

`supervisord.conf` — это файл в стиле Windows-INI (Python ConfigParser). Он имеет разделы (каждый из которых обозначается `[header]`) и пары ключ/значение внутри разделов. Разделы и их допустимые значения описаны ниже.

### Переменные среды

Переменные среды, присутствующие в среде во время запуска **supervisord**, можно использовать в файле конфигурации с использованием синтаксиса строкового выражения Python `%(ENV_X)s`:

```ini
[program:example]
command=/usr/bin/example --loglevel=%(ENV_LOGLEVEL)s
```

В приведенном выше примере выражение `%(ENV_LOGLEVEL)s` будет расширено до значения переменной среды **LOGLEVEL**.

{% hint style="info" %}
В **Supervisor 3.2** и более поздних версиях выражения `%(ENV_X)s` поддерживаются во всех параметрах. В предыдущих версиях некоторые параметры поддерживают их, но большинство — нет. См. документацию для каждой опции ниже.
{% endhint %}

## Настройки раздела `[unix_http_server]`

Файл `supervisord.conf` содержит раздел с именем `[unix_http_server]`, в котором должны быть вставлены параметры конфигурации для HTTP-сервера, который прослушивает сокет домена **UNIX**. Если в конфигурационном файле нет секции `[unix_http_server]`, HTTP-сервер сокета домена **UNIX** не будет запущен. Допустимые значения конфигурации следующие.

### Секция значений `[unix_http_server]`

**`file`**

Путь к сокету домена **UNIX**, на котором супервизор будет прослушивать запросы **HTTP/XML-RPC**. **supervisorctl** использует XML-RPC для связи с **supervisord** через этот порт. Эта опция может включать значение `%(here)s`, которое расширяется до каталога, в котором был найден файл конфигурации **supervisord**.

_По умолчанию_: `None`.

_Требуется_: Нет.

_Введено_: 3.0

{% hint style="warning" %}
Пример конфигурации, выводимый **echo\_supervisord\_conf**, использует `/tmp/supervisor.sock` в качестве файла сокета. Этот путь приведен только в качестве примера, и, вероятно, его нужно будет изменить на более подходящее для вашей системы место. Некоторые системы периодически удаляют старые файлы в `/tmp`. Если файл сокета будет удален, **supervisorctl** не сможет подключиться к **supervisord**.
{% endhint %}

**`chmod`**

Изменяет биты режима разрешений UNIX сокета домена UNIX на это значение при запуске.

_По умолчанию_: `0700`.

_Требуется_: Нет.

_Введено_: 3.0

**`chown`**

Измените пользователя и группу файла сокета на это значение. Может быть именем пользователя UNIX (например, **chrism**) или именем пользователя UNIX и группой, разделенными двоеточием (например, **chrism:wheel**).

_По умолчанию_: Использутся имя пользователя и группа пользователя, который запускает **supervisord**.

_Требуется_: Нет.

_Введено_: 3.0

**`username`**

Имя пользователя, необходимое для аутентификации на этом HTTP-сервере.

_По умолчанию_: Имя пользователя не требуется.

_Требуется_: Нет.

_Введено_: 3.0

**`password`**

Пароль, необходимый для аутентификации на этом HTTP-сервере. Это может быть пароль в открытом виде или указанный в виде хэша **SHA-1**, если перед ним стоит строка `{SHA}`. Например, `{SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d` — это хранящаяся в SHA версия пароля «thepassword».

Обратите внимание, что хешированный пароль должен быть в шестнадцатеричном формате.

_По умолчанию_: Пароль не требуется.

_Требуется_: Нет.

_Введено_: 3.0

### Пример секции `[unix_http_server]`

```ini
[unix_http_server]
file = /tmp/supervisor.sock
chmod = 0777
chown= nobody:nogroup
username = user
password = 123
```

## Настройки раздела `[inet_http_server]`

Файл `supervisord.conf` содержит раздел с именем `[inet_http_server]`, в котором должны быть вставлены параметры конфигурации для HTTP-сервера, который прослушивает сокет TCP (интернет). Если в конфигурационном файле нет раздела `[inet_http_server]`, HTTP-сервер inet не будет запущен. Допустимые значения конфигурации следующие.

{% hint style="warning" %}
HTTP-сервер inet не включен по умолчанию. Если вы решите включить его, прочтите следующее предупреждение о безопасности. HTTP-сервер inet предназначен для использования только в доверенной среде. Он должен быть привязан только к локальному хосту или доступен только из изолированной доверенной сети. HTTP-сервер inet не поддерживает никакие формы шифрования. HTTP-сервер inet по умолчанию не использует аутентификацию (см. параметры **username=** и **password=**). HTTP-сервером inet можно управлять удаленно из **supervisorctl**. Он также обслуживает веб-интерфейс, который позволяет запускать или останавливать подпроцессы и просматривать журналы подпроцессов. **Никогда не выставляйте HTTP-сервер inet в общедоступный Интернет.**
{% endhint %}

### Секция значений `[inet_http_server]`

**`port`**

Значение TCP **host:port** или (например, `127.0.0.1:9001`), на котором супервизор будет прослушивать запросы **HTTP/XML-RPC**. **supervisorctl** будет использовать XML-RPC для связи с **supervisord** через этот порт. Чтобы прослушивать все интерфейсы машины, используйте `:9001` или `*:9001`. Пожалуйста, прочтите предупреждение о безопасности выше.

_По умолчанию_: Нет по умолчанию.

_Требуется_: Да.

_Введено_: 3.0

**`username`**

Имя пользователя, необходимое для аутентификации на этом HTTP-сервере.

_По умолчанию_: Имя пользователя не требуется.

_Требуется_: Нет.

_Введено_: 3.0

**`password`**

Пароль, необходимый для аутентификации на этом HTTP-сервере. Это может быть пароль в открытом виде или указанный в виде хэша **SHA-1**, если перед ним стоит строка `{SHA}`. Например, `{SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d` — это хранящаяся в SHA версия пароля «thepassword».

Обратите внимание, что хешированный пароль должен быть в шестнадцатеричном формате.

_По умолчанию_: Пароль не требуется.

_Требуется_: Нет.

_Введено_: 3.0

### Пример секции `[inet_http_server]`

```ini
[inet_http_server]
port = 127.0.0.1:9001
username = user
password = 123
```

## Настройки раздела `[supervisord]`

Файл `supervisord.conf` содержит раздел с именем `[supervisord]`, в который должны быть вставлены глобальные настройки, относящиеся к процессу **supervisord**. Они заключаются в следующем.

### Секция значений `[supervisord]`

**`logfile`**

Путь к журналу действий процесса **supervisord**. Эта опция может включать значение `%(here)s`, которое расширяется до каталога, в котором был найден файл конфигурации **supervisord**.

{% hint style="info" %}
Если **logfile** задан как специальный файл, такой как `/dev/stdout`, который не доступен для поиска, необходимо отключить ротацию журнала, установив `logfile_maxbytes = 0`.
{% endhint %}

_По умолчанию_: `$CWD/supervisord.log`.

_Требуется_: Нет.

_Введено_: 3.0

**`logfile_maxbyte`**

Максимальное количество байтов, которое может быть использовано файлом журнала активности до его ротации (в значении можно использовать множители суффиксов, такие как «KB», «MB» и «GB»). Установите это значение равным `0`, чтобы указать неограниченный размер журнала.

_По умолчанию_: 50MB

_Требуется_: Нет.

_Введено_: 3.0

**`logfile_backups`**

Количество резервных копий, которые необходимо сохранить в результате ротации файлов журнала активности. Если установлено значение `0`, резервные копии не сохраняются.

_По умолчанию_: 10

_Требуется_: Нет.

_Введено_: 3.0

**`loglevel`**

Уровень ведения журнала, определяющий, что записывается в журнал действий **supervisord**. Одно из **critical**, **error**, **warn**, **info**, **debug**, **trace** или **blather**. Обратите внимание, что при  уровне журнала **debug** файл журнала **supervisord** будет записывать выходные данные `stderr/stdout` своих дочерних процессов и расширенную информацию об изменениях состояния процесса, что полезно для отладки процесса, который не запускается должным образом. См. также: <mark style="color:purple;">Уровни журнала действий</mark>.

_По умолчанию_: **info**

_Требуется_: Нет.

_Введено_: 3.0

**`pidfile`**

Расположение, в котором **supervisord** хранит свой файл **pid**. Эта опция может включать значение `%(here)s`, которое расширяется до каталога, в котором был найден файл конфигурации **supervisord**.

_По умолчанию_: `$CWD/supervisord.pid`

_Требуется_: Нет.

_Введено_: 3.0

**`umask`**

[umask](http://supervisord.org/glossary.html#term-umask) процесса **supervisord**.

_По умолчанию_: `022`

_Требуется_: Нет.

_Введено_: 3.0

**`nodaemon`**

Если `true`, **supervisord** запустится на переднем плане, а не демонизируется.

_По умолчанию_: `false`

_Требуется_: Нет.

_Введено_: 3.0

**`silent`**

Если значение равно `true` и не демонизировано, журналы не будут направляться на стандартный вывод stdout.

_По умолчанию_: `false`

_Требуется_: Нет.

_Введено_: 4.2.0

**`minfds`**

Минимальное количество файловых дескрипторов, которое должно быть доступно для успешного запуска **supervisord**. Будет сделан вызов **setrlimit**, чтобы попытаться поднять мягкие и жесткие ограничения процесса **supervisord**, чтобы удовлетворить **minfds**. Жесткое ограничение может быть увеличено только в том случае, если **supervisord** запущен от имени пользователя **root**. **supervisord** свободно использует файловые дескрипторы и переходит в режим сбоя, когда его нельзя получить из ОС, поэтому полезно иметь возможность указать минимальное значение, чтобы гарантировать, что они не закончатся во время выполнения. Эти ограничения будут унаследованы управляемыми подпроцессами. Этот параметр особенно полезен в **Solaris**, где по умолчанию установлен низкий предел **fd** для каждого процесса.

_По умолчанию_: `1024`

_Требуется_: Нет.

_Введено_: 3.0

**`minprocs`**

Минимальное количество дескрипторов процессов, которое должно быть доступно для успешного запуска **supervisord**. Будет сделан вызов **setrlimit**, чтобы попытаться повысить мягкие и жесткие ограничения процесса **supervisord**, чтобы удовлетворить требования **minprocs**. Жесткое ограничение может быть увеличено только в том случае, если **supervisord** запущен от имени пользователя **root**. **supervisord** перейдет в режим сбоя, когда в ОС закончатся дескрипторы процессов, поэтому полезно убедиться, что при запуске **supervisord** доступно достаточное количество дескрипторов процессов.

_По умолчанию_: `200`

_Требуется_: Нет.

_Введено_: 3.0

**`nocleanup`**

Предотвращает очистку **supervisord** любых существующих дочерних файлов журнала **AUTO** во время запуска. Полезно для отладки.

_По умолчанию_: `false`

_Требуется_: Нет.

_Введено_: 3.0

**`childlogdir`**

Каталог, используемый для дочерних файлов журнала **AUTO**. Эта опция может включать значение `%(here)s`, которое расширяется до каталога, в котором был найден файл конфигурации **supervisord**.

_По умолчанию_: значение Python `tempfile.gettempdir()`

_Требуется_: Нет.

_Введено_: 3.0

**`user`**

Поручает **supervisord** переключить пользователей на эту учетную запись пользователя UNIX, прежде чем выполнять какую-либо значимую обработку. Пользователь может быть переключен только в том случае, если **supervisord** запущен как пользователь **root**.

_По умолчанию_: не переключает пользователей

_Требуется_: Нет.

_Введено_: 3.0

_Изменено_: **3.3.4**. Если **supervisord** не может переключиться на указанного пользователя, он напишет сообщение об ошибке в **stderr** и немедленно завершит работу. В более ранних версиях он продолжал работать, но регистрировал сообщение на критическом уровне.

**`directory`**

Когда **supervisord** демонизируется, то переключается в этот каталог. Эта опция может включать значение `%(here)s`, которое расширяется до каталога, в котором был найден файл конфигурации **supervisord**.

_По умолчанию_: не делает cd

_Требуется_: Нет.

_Введено_: 3.0

**`strip_ansi`**

Удаляет все escape-последовательности ANSI из дочерних файлов журналов.

_По умолчанию_: `false`

_Требуется_: Нет.

_Введено_: 3.0

**`environment`**

Список пар ключ/значение в виде `KEY="val",KEY2="val2"`, которые будут помещены в среду всех дочерних процессов. Это не меняет среду самого **supervisord**. Эта опция может включать значение `%(here)s`, которое расширяется до каталога, в котором был найден файл конфигурации **supervisord**. Значения, содержащие небуквенно-цифровые символы, следует заключать в кавычки (например, `KEY="val:123",KEY2="val,456"`). В противном случае заключать значения в кавычки необязательно, но рекомендуется. Чтобы экранировать символы процента, просто используйте два символа (например, `URI="/first%%20name"`). Обратите внимание, что подпроцессы наследуют переменные среды оболочки, используемые для запуска **supervisord**, за исключением тех, которые переопределены здесь и в параметрах **environment** программы. См. <mark style="color:purple;">Среда подпроцесса</mark>.

_По умолчанию_: нет значения

_Требуется_: Нет.

_Введено_: 3.0

**`identifier`**

Строка идентификатора для этого процесса **supervisord**, используемого интерфейсом RPC.

_По умолчанию_: supervisor

_Требуется_: Нет.

_Введено_: 3.0

### Пример секции `[supervisord]`

```ini
[supervisord]
logfile = /tmp/supervisord.log
logfile_maxbytes = 50MB
logfile_backups=10
loglevel = info
pidfile = /tmp/supervisord.pid
nodaemon = false
minfds = 1024
minprocs = 200
umask = 022
user = chrism
identifier = supervisor
directory = /tmp
nocleanup = true
childlogdir = /tmp
strip_ansi = false
environment = KEY1="value1",KEY2="value2"
```

## Настройки раздела `[supervisorctl]`

Файл конфигурации может содержать настройки интерактивной оболочки **supervisorctl**. Эти параметры перечислены ниже.

### Секция значений `[supervisorctl]`

**`serverurl`**

URL-адрес, который следует использовать для доступа к серверу **supervisord**, например, `http://localhost:9001`. Для сокетов домена UNIX используйте `unix:///absolute/path/to/file.sock`.

_По умолчанию_: `http://localhost:9001`

_Требуется_: Нет.

_Введено_: 3.0

**`username`**

Имя пользователя для передачи на сервер **supervisord** для использования при аутентификации. Это должно совпадать с **username** из конфигурации сервера **supervisord** для порта или сокета домена UNIX, к которому вы пытаетесь получить доступ.

_По умолчанию_: нет username

_Требуется_: Нет.

_Введено_: 3.0

**`password`**

Пароль для передачи на сервер **supervisord** для использования при аутентификации. Это должна быть версия пароля в открытом виде из конфигурации сервера **supervisord** для порта или сокета домена UNIX, к которому вы пытаетесь получить доступ. Это значение _**нельзя**_ передавать в виде хэша SHA. В отличие от других паролей, указанных в этом файле, он должен быть предоставлен в открытом виде.

_По умолчанию_: нет password

_Требуется_: Нет.

_Введено_: 3.0

**`prompt`**

Строка, используемая в качестве приглашения **supervisorctl**.

_По умолчанию_: `supervisor`

_Требуется_: Нет.

_Введено_: 3.0

**`history_file`**

Путь для использования в качестве файла постоянной истории **readline**. Если вы включите эту функцию, выбрав путь, ваши команды **supervisorctl** будут храниться в файле, и вы сможете использовать строку чтения (например, стрелку вверх) для вызова команд, которые вы выполняли в своем последнем сеансе **supervisorctl**.

_По умолчанию_: нет файла

_Требуется_: Нет.

_Введено_: 3.0a5

### Пример секции `[supervisorctl]`

```ini
[supervisorctl]
serverurl = unix:///tmp/supervisor.sock
username = chris
password = 123
prompt = mysupervisor
```

## Настройки раздела `[program:x]`

Файл конфигурации должен содержать один или несколько разделов **program**, чтобы **supervisord** знал, какие программы он должен запускать и контролировать. Значение заголовка является составным значением. Это слово `"program"`, за которым следует двоеточие, а затем имя программы. Значение заголовка `[program:foo]` описывает программу с именем `"foo"`. Имя используется в клиентских приложениях, управляющих процессами, созданными в результате этой конфигурации. Создание раздела **program**, не имеющего имени, является ошибкой. Имя не должно содержать двоеточие или квадратную скобку. Значение имени используется в качестве значения для расширения строкового выражения `%(program_name)s` в пределах других значений, если они указаны.

{% hint style="info" %}
Раздел **\[program:x]** фактически представляет «однородную группу процессов» для супервизора (начиная с версии `3.0`). Члены группы определяются комбинацией параметров **numprocs** и **process\_name** в конфигурации. По умолчанию, если **numprocs** и **process\_name** не изменены по сравнению со значениями по умолчанию, группа, представленная **\[program:x]**, будет называться **x** и будет иметь в ней один процесс с именем **x**. Это обеспечивает некоторую обратную совместимость со старыми версиями супервизора, в которых разделы программы не рассматривались как однородные определения групп процессов.

Но, например, если у вас есть раздел **\[program:foo]** с **numprocs**, равным 3, и выражением **process\_name**, равным `%(program_name)s_%(process_num)02d`, группа «foo» будет содержать три процесса с именами **foo\_00**, **foo\_01**, и **foo\_02**. Это позволяет запускать несколько очень похожих процессов, используя один раздел **\[program:x]**. Все имена файлов журналов, все строки среды и команды программ также могут содержать аналогичные строковые выражения Python для передачи немного разных параметров каждому процессу.
{% endhint %}

### Секция значений `[program:x]`

**`command`**

Команда, которая будет выполняться при запуске этой программы. Команда может быть как абсолютной (например, `/path/to/programname`), так и относительной (например, `programname`). Если он относительный, исполняемый файл будет искаться в среде **supervisord** `$PATH`. Программы могут принимать аргументы, например, `/path/to/program foo bar`. Командная строка может использовать двойные кавычки для группировки аргументов с пробелами в них для передачи в программу, например, `/path/to/program/name -p "foo bar"`. Обратите внимание, что значение команды может включать строковые выражения Python, например, `/path/to/programname --port=80%(process_num)02d` может расширяться до `/path/to/programname --port=8000` во время выполнения. Строковые выражения оцениваются по словарю, содержащему ключи **group\_name**, **host\_node\_name**, **program\_name**, **process\_num**, **numprocs**, **here** (каталог файла конфигурации **supervisord**) и все переменные среды **supervisord** с префиксом **ENV\_**. Управляемые программы сами по себе не должны быть демонами, так как **supervisord** предполагает, что он несет ответственность за демонизацию своих подпроцессов (см. <mark style="color:purple;">Недемонизация подпроцессов</mark>).

{% hint style="info" %}
Команда будет усечена, если она выглядит как комментарий к файлу конфигурации, например, `command=bash -c 'foo ; bar'` будет усечен до `command=bash -c 'foo`. Заключение в кавычки не предотвратит такое поведение, поскольку программа чтения файла конфигурации не анализирует команду, как это делает оболочка.
{% endhint %}

_По умолчанию_: нет значения по умолчанию

_Требуется_: Да.

_Введено_: 3.0

_Изменено_: **4.2.0**. Добавлена поддержка расширения **numprocs**.

**`process_name`**

Строковое выражение Python, которое используется для составления имени процесса супервизора для этого процесса. Обычно вам не нужно беспокоиться об установке этого параметра, если только вы не измените **numprocs**. Строковое выражение оценивается по словарю, который включает **group\_name**, **host\_node\_name**, **process\_num**, **program\_name** и **here** (каталог файла конфигурации **supervisord**).

_По умолчанию_: `%(program_name)s`

_Требуется_: Нет.

_Введено_: 3.0

**`numprocs`**

Supervisor запустит столько экземпляров этой программы, сколько указано в **numprocs**. Обратите внимание, что если `numprocs > 1`, выражение **process\_name** должно включать в себя `%(process_num)s` (или любое другое допустимое строковое выражение Python, включающее **process\_num**).

_По умолчанию_: 1

_Требуется_: Нет.

_Введено_: 3.0

**`numprocs_start`**

Целочисленное смещение, используемое для вычисления числа, с которого начинается **process\_num**.

_По умолчанию_: 0

_Требуется_: Нет.

_Введено_: 3.0

**`priority`**

Относительный приоритет программы в порядке запуска и завершения работы. Более низкие приоритеты указывают на программы, которые запускаются первыми и закрываются последними при запуске, а также когда в разных клиентах используются агрегированные команды (например, `"start all"/"stop all"`). Более высокие приоритеты указывают на программы, которые запускаются последними и закрываются первыми.

_По умолчанию_: 999

_Требуется_: Нет.

_Введено_: 3.0

**`autostart`**

Если `true`, эта программа запустится автоматически при запуске **supervisord**.

_По умолчанию_: `true`

_Требуется_: Нет.

_Введено_: 3.0

**`startsecs`**

Общее количество секунд, в течение которых программа должна продолжать работу после запуска, чтобы считать запуск успешным (перевод процесса из состояния **STARTING** в состояние **RUNNING**). Установите значение `0`, чтобы указать, что программа не должна оставаться запущенной какое-то определенное время.

{% hint style="info" %}
Даже если процесс завершается с «ожидаемым» кодом выхода (см. **exitcodes**), запуск все равно будет считаться неудачным, если процесс завершится быстрее, чем **startsecs**.
{% endhint %}

_По умолчанию_: 1

_Требуется_: Нет.

_Введено_: 3.0

**`startretries`**

Количество последовательных неудачных попыток, которые **supervisord** допускает при попытке запустить программу, прежде чем сдаться и перевести процесс в состояние **FATAL**.

{% hint style="info" %}
После каждого неудачного перезапуска процесс будет переведен в состояние **BACKOFF**, и каждая повторная попытка будет занимать все больше времени.

См. «<mark style="color:purple;">Состояния процесса</mark>» для объяснения состояний **FATAL** и **BACKOFF**.
{% endhint %}

_По умолчанию_: 3

_Требуется_: Нет.

_Введено_: 3.0

**`autorestart`**

Указывает, должен ли **supervisord** автоматически перезапускать процесс, если он завершает работу, находясь в состоянии **RUNNING**. Может быть одним из **false**, **unexpected** или **true**. Если **false**, процесс не будет перезапущен автоматически. В случае **unexpected** процесс будет перезапущен при завершении программы с кодом выхода, который не является одним из кодов выхода, связанных с конфигурацией этого процесса (см. **exitcodes**). Если **true**, процесс будет безоговорочно перезапущен при выходе, независимо от его кода выхода.

{% hint style="info" %}
**autorestart** определяет, будет ли **supervisord** автоматически перезапускать программу, если она завершает работу после успешного запуска (процесс находится в состоянии **RUNNING**).

В **supervisord** используется другой механизм перезапуска, когда процесс запускается (процесс находится в состоянии **STARTING**). Повторы во время запуска процесса контролируются **startsecs** и **startretries**.
{% endhint %}

_По умолчанию_: **unexpected**

_Требуется_: Нет.

_Введено_: 3.0

**`exitcodes`**

Список «ожидаемых» кодов выхода для этой программы, используемой при **autorestart**. Если для параметра **autorestart** задано значение **unexpected**, а процесс завершается каким-либо иным образом, кроме как в результате запроса **supervisord** на остановку, **supervisord** перезапустит процесс, если он завершится с кодом выхода, не определенным в этом списке.

_По умолчанию_: 0

_Требуется_: Нет.

_Введено_: 3.0

{% hint style="info" %}
В версиях Supervisor до 4.0 по умолчанию было `0,2`. В Supervisor 4.0 значение по умолчанию было изменено на `0`.
{% endhint %}

**`stopsignal`**

Сигнал, используемый для уничтожения программы при запросе остановки. Это можно указать, используя имя сигнала или его номер. Обычно это одно из следующих значений: **TERM**, **HUP**, **INT**, **QUIT**, **KILL**, **USR1** или **USR2**.

_По умолчанию_: **TERM**

_Требуется_: Нет.

_Введено_: 3.0

**`stopwaitsecs`**

Время ожидания в секундах, пока ОС не вернет **SIGCHLD** супервизору после того, как программе был отправлен сигнал остановки. Если это количество секунд истечет до того, как **supervisord** получит **SIGCHLD** от процесса, **supervisord** попытается убить его с помощью последнего **SIGKILL**.

_По умолчанию_: 10

_Требуется_: Нет.

_Введено_: 3.0

**`stopasgroup`**

Если этот флаг равен **true**, **supervisord** отправляет сигнал остановки всей группе процессов и подразумевает, что **killasgroup** имеет значение **true**. Это полезно для таких программ, как **Flask** в режиме отладки, которые не передают стоп-сигналы своим дочерним элементам, оставляя их сиротами.

_По умолчанию_: **false**

_Требуется_: Нет.

_Введено_: 3.0b1

**`killasgroup`**

Если это **true**, то при отправке **SIGKILL** в программу для завершения она вместо этого отправляет его всей своей группе процессов, заботясь также и о своих дочерних элементах, что полезно, например, с программами Python, использующими _**многопроцессорность**_.

_По умолчанию_: **false**

_Требуется_: Нет.

_Введено_: 3.0a11

**`user`**

Поручает **supervisord** использовать эту учетную запись пользователя UNIX в качестве учетной записи, под которой запускается программа. Пользователь может быть переключен только в том случае, если **supervisord** запущен как пользователь **root**. Если **supervisord** не может переключиться на указанного пользователя, программа не будет запущена.

_По умолчанию_: Не переключает пользователей

_Требуется_: Нет.

_Введено_: 3.0

**`redirect_stderr`**

Если значение равно **true**, вывод **stderr** процесса будет отправлен обратно в **supervisord** в его файловом дескрипторе **stdout** (в терминах оболочки UNIX это эквивалентно выполнению `/the/program 2>&1`).

_По умолчанию_: **false**

_Требуется_: Нет.

_Введено_: 3.0, заменяет **log\_stdout** и **log\_stderr** версии 2.0

**`stdout_logfile`**

Помещает вывод процесса **stdout** в этот файл (и, если **redirect\_stderr** имеет значение **true**, также помещает вывод **stderr** в этот файл). Если **stdout\_logfile** не установлен или установлен на **AUTO**, супервизор автоматически выберет расположение файла. Если установлено значение **NONE**, **supervisord** не будет создавать файл журнала. Файлы журналов **AUTO** и их резервные копии будут удалены при перезапуске **supervisord**. Значение **stdout\_logfile** может содержать строковые выражения Python, которые будут оцениваться по словарю, содержащему **group\_name**, **host\_node\_name**, **process\_num**, **program\_name** и **here** (каталог файла конфигурации **supervisord**).

{% hint style="info" %}
Два процесса не могут совместно использовать один файл журнала (**stdout\_logfile**), если включена ротация (**stdout\_logfile\_maxbytes**). Это приведет к повреждению файла.
{% endhint %}

{% hint style="info" %}
Если для **stdout\_logfile** задан специальный файл, такой как **/dev/stdout**, который не доступен для поиска, необходимо отключить ротацию журналов, установив `stdout_logfile_maxbytes = 0`.
{% endhint %}

_По умолчанию_: **AUTO**

_Требуется_: Нет.

_Введено_: 3.0, заменяет **logfile** версии 2.0

**`stdout_logfile_maxbytes`**

Максимальное количество байтов, которые может использовать файл **stdout\_logfile** до его ротации (в значении можно использовать множители суффиксов, такие как «KB», «MB» и «GB»). Установите это значение равным `0`, чтобы указать неограниченный размер журнала.

_По умолчанию_: 50MB

_Требуется_: Нет.

_Введено_: 3.0, заменяет **logfile\_maxbytes** версии 2.0

**`stdout_logfile_backups`**

Количество сохраняемых резервных копий **stdout\_logfile** в результате ротации файлов журнала **stdout** процесса. Если установлено значение `0`, резервные копии не сохраняются.

_По умолчанию_: 10

_Требуется_: Нет.

_Введено_: 3.0, заменяет **logfile\_backups** версии 2.0

**`stdout_capture_maxbytes`**

Максимальное количество байтов, записываемых для захвата **FIFO**, когда процесс находится в «режиме захвата стандартного вывода» (см. «<mark style="color:purple;">Режим захвата</mark>»). Должно быть целым числом (в значении могут использоваться суффиксные множители, такие как «KB», «MB» и «GB»). Если это значение равно `0`, режим захвата процесса будет отключен.

_По умолчанию_: 0

_Требуется_: Нет.

_Введено_: 3.0

**`stdout_events_enabled`**

Если **true**, события **PROCESS\_LOG\_STDOUT** будут генерироваться, когда процесс записывает в свой файловый дескриптор **stdout**. События будут генерироваться только в том случае, если файловый дескриптор не находится в режиме захвата во время получения данных (см. <mark style="color:purple;">Режим захвата</mark>).

_По умолчанию_: 0

_Требуется_: Нет.

_Введено_: 3.0a7

**`stdout_syslog`**

Если **true**, стандартный вывод будет направлен в системный журнал вместе с именем процесса.

_По умолчанию_: **false**

_Требуется_: Нет.

_Введено_: 4.0.0

**`stderr_logfile`**

Помещает вывод процесса **stderr** в этот файл, если только **redirect\_stderr** не имеет значения **true**. Принимает те же типы значений, что и **stdout\_logfile**, и может содержать те же строковые выражения Python.

{% hint style="info" %}
Два процесса не могут совместно использовать один файл журнала (**stderr\_logfile**), если включена ротация (**stderr\_logfile\_maxbytes**). Это приведет к повреждению файла.
{% endhint %}

{% hint style="info" %}
Если для **stderr\_logfile** задан специальный файл, такой как **/dev/stderr**, который не доступен для поиска, необходимо отключить ротацию журналов, установив `stderr_logfile_maxbytes = 0`.
{% endhint %}

_По умолчанию_: **AUTO**

_Требуется_: Нет.

_Введено_: 3.0

**`stderr_logfile_maxbytes`**

Максимальное количество байтов до ротации файла журнала для **stderr\_logfile**. Принимает те же типы значений, что и **stdout\_logfile\_maxbytes**.

_По умолчанию_: 50MB

_Требуется_: Нет.

_Введено_: 3.0

**`stderr_logfile_backups`**

Количество резервных копий, которые необходимо сохранить в результате ротации файлов журнала **stderr** процесса. Если установлено значение `0`, резервные копии не сохраняются.

_По умолчанию_: 10

_Требуется_: Нет.

_Введено_: 3.0

**`stderr_capture_maxbytes`**

Максимальное количество байтов, записываемых в буфер **FIFO**, когда процесс находится в «режиме захвата stderr» (см. «<mark style="color:purple;">Режим захвата</mark>»). Должно быть целым числом (в значении могут использоваться суффиксные множители, такие как «KB», «MB» и «GB»). Если это значение равно `0`, режим захвата процесса будет отключен.

_По умолчанию_: 0

_Требуется_: Нет.

_Введено_: 3.0

**`stderr_events_enabled`**

Если **true**, события **PROCESS\_LOG\_STDERR** будут генерироваться, когда процесс записывает в свой файловый дескриптор **stderr**. События будут генерироваться только в том случае, если файловый дескриптор не находится в режиме захвата во время получения данных (см. <mark style="color:purple;">Режим захвата</mark>).

_По умолчанию_: 0

_Требуется_: Нет.

_Введено_: 3.0a7

**`stderr_syslog`**

Если **true**, **stderr** будет направлен в системный журнал вместе с именем процесса.

_По умолчанию_: **false**

_Требуется_: Нет.

_Введено_: 4.0.0

**`environment`**

Список пар ключ/значение в форме `KEY="val",KEY2="val2"`, которые будут помещены в среду дочернего процесса. Строка среды может содержать строковые выражения Python, которые будут оцениваться по словарю, содержащему **group\_name**, **host\_node\_name**, **process\_num**, **program\_name** и **here** (каталог файла конфигурации **supervisord**). Значения, содержащие небуквенно-цифровые символы, следует заключать в кавычки (например, `KEY="val:123",KEY2="val,456"`). В противном случае заключать значения в кавычки необязательно, но рекомендуется. Обратите внимание, что подпроцесс наследует переменные среды оболочки, используемые для запуска **supervisord**, за исключением тех, которые здесь переопределены. См. <mark style="color:purple;">Среда подпроцесса</mark>.

_По умолчанию_: Без дополнительной среды

_Требуется_: Нет.

_Введено_: 3.0

**`directory`**

Путь к файлу, представляющий каталог, в который **supervisord** должен временно перейти перед выполнением дочернего процесса.

_По умолчанию_: Нет chdir (наследует супервизор)

_Требуется_: Нет.

_Введено_: 3.0

**`umask`**

Восьмеричное число (например, `002`, `022`), представляющее **umask** процесса.

_По умолчанию_: Нет специального umask (наследует супервизор)

_Требуется_: Нет.

_Введено_: 3.0

**`serverurl`**

URL-адрес, передаваемый в среде процессу подпроцесса как **SUPERVISOR\_SERVER\_URL** (см. `supervisor.childutils`), чтобы позволить подпроцессу легко взаимодействовать с внутренним HTTP-сервером. Если он предоставлен, он должен иметь тот же синтаксис и структуру, что и параметр раздела `[supervisorctl]` с тем же именем. Если для этого параметра установлено значение **AUTO** или оно не установлено, супервизор автоматически создает URL-адрес сервера, отдавая предпочтение серверу, который прослушивает сокеты домена UNIX, а не серверу, который прослушивает интернет-сокет.

_По умолчанию_: **AUTO**

_Требуется_: Нет.

_Введено_: 3.0

### Пример секции `[program:x]`

```ini
[program:cat]
command=/bin/cat
process_name=%(program_name)s
numprocs=1
directory=/tmp
umask=022
priority=999
autostart=true
autorestart=unexpected
startsecs=10
startretries=3
exitcodes=0
stopsignal=TERM
stopwaitsecs=10
stopasgroup=false
killasgroup=false
user=chrism
redirect_stderr=false
stdout_logfile=/a/path
stdout_logfile_maxbytes=1MB
stdout_logfile_backups=10
stdout_capture_maxbytes=1MB
stdout_events_enabled=false
stderr_logfile=/a/path
stderr_logfile_maxbytes=1MB
stderr_logfile_backups=10
stderr_capture_maxbytes=1MB
stderr_events_enabled=false
environment=A="1",B="2"
serverurl=AUTO
```

## Настройки раздела `[include]`

Файл `supervisord.conf` может содержать раздел с именем `[include]`. Если файл конфигурации содержит раздел `[include]`, он должен содержать единственный ключ с именем `"files"`. Значения в этом ключе указывают другие файлы конфигурации, которые должны быть включены в конфигурацию.

{% hint style="info" %}
Раздел **\[include]** обрабатывается только **supervisord**. **supervisorctl** игнорирует его.
{% endhint %}

### Секция значений `[include]`

**`files`**

Разделенная пробелом последовательность файловых путей (glob). Каждый путь файл может быть абсолютным или относительным. Если путь файла (glob) является относительным, он считается относительным к местоположению файла конфигурации, который его включает. «Glob» — это шаблон файла, который соответствует указанному шаблону в соответствии с правилами, используемыми оболочкой Unix. Расширение тильды не выполняется, но `*`, `?` и диапазоны символов, выраженные с помощью `[]`, будут правильно сопоставлены. Строковое выражение оценивается по словарю, который включает **host\_node\_name** и **here** (каталог файла конфигурации **supervisord**). Рекурсивное включение из включаемых файлов не поддерживается.

_По умолчанию_: Нет значения по умолчанию

_Требуется_: Да.

_Введено_: 3.0

_Изменено_: **3.3.0**. Добавлена поддержка расширения **host\_node\_name**.

### Пример секции `[include]`

```ini
[include]
files = /an/absolute/filename.conf /an/absolute/*.conf foo.conf config??.conf
```

## Настройки раздела `[group:x]`

Часто бывает полезно сгруппировать «однородные» группы процессов (также известные как «программы») вместе в «гетерогенную» группу процессов, чтобы ими можно было управлять как единым целым с различных интерфейсов контроллера Supervisor.

Чтобы поместить программы в группу, чтобы вы могли рассматривать их как единое целое, определите раздел `[group:x]` в вашем файле конфигурации. Значение заголовка группы является составным. Это слово `"group"`, за которым следует двоеточие, а затем название группы. Значение заголовка `[group:foo]` описывает группу с именем `«foo»`. Имя используется в клиентских приложениях, управляющих процессами, созданными в результате этой конфигурации. Создание раздела группы без названия является ошибкой. Имя не должно содержать двоеточие или квадратную скобку.

Для `[group:x]` в вашем файле конфигурации должен быть один или несколько разделов `[program:x]`, и группа должна ссылаться на них по имени в значении **programs**.

Если «однородные» группы процессов (представленные разделами программы) помещаются в «гетерогенную» группу через строку **programs** раздела `[group:x]`, однородные группы, подразумеваемые разделом **program**, не будут существовать во время выполнения в супервизоре. Вместо этого все процессы, принадлежащие каждой из однородных групп, будут помещены в гетерогенную группу. Например, при следующей конфигурации группы:

```ini
[group:foo]
programs=bar,baz
priority=999
```

Учитывая вышеизложенное, при запуске **supervisord** однородных групп **bar** и **baz** не будет, а процессы, которые находились бы под ними, теперь будут перемещены в группу **foo**.

### Секция значений `[group:x]`

**`programs`**

Список имен программ, разделенных запятыми. Перечисленные программы становятся членами группы.

_По умолчанию_: Нет значения по умолчанию

_Требуется_: Да.

_Введено_: 3.0

**`priority`**

Номер приоритета, аналогичный значению приоритета `[program:x]`, назначенному группе.

_По умолчанию_: 999

_Требуется_: Нет.

_Введено_: 3.0

### Пример секции `[group:x]`

```ini
[group:foo]
programs=bar,baz
priority=999
```

## Настройки раздела `[fcgi-program:x]`

Supervisor может управлять группами процессов [FastCGI](http://www.fastcgi.com/), которые прослушивают один и тот же сокет. До сих пор гибкость развертывания FastCGI была ограничена. Чтобы получить полное управление процессами, вы могли бы использовать **mod\_fastcgi** под Apache, но тогда вы застряли бы с неэффективной моделью параллелизма Apache — один процесс или поток на одно соединение. Помимо того, что требуется больше ресурсов ЦП и памяти, модель процесса/потока на соединение может быть быстро насыщена медленным ресурсом, что не позволяет обслуживать другие ресурсы. Чтобы воспользоваться преимуществами более новых веб-серверов, управляемых событиями, таких как **lighttpd** или **nginx**, которые не включают встроенный диспетчер процессов, вам пришлось использовать скрипты, такие как **cgi-fcgi** или **spawn-fcgi**. Их можно использовать в сочетании с диспетчером процессов, таким как **supervisord** или **daemontools**, но для этого требуется, чтобы каждый дочерний процесс FastCGI привязывался к своему собственному сокету. Недостатками этого являются: излишне сложная конфигурация веб-сервера, неудобные перезапуски и снижение отказоустойчивости. При меньшем количестве сокетов для настройки конфигурация веб-сервера становится намного меньше, если группы процессов FastCGI могут совместно использовать сокеты. Общие сокеты допускают плавный перезапуск, поскольку сокет остается привязанным к родительскому процессу, пока перезапускается любой из дочерних процессов. Наконец, общие сокеты более отказоустойчивы, поскольку в случае сбоя данного процесса другие процессы могут продолжать обслуживать входящие соединения.

Благодаря встроенной поддержке запуска FastCGI Supervisor дает вам лучшее из обоих миров. Вы получаете полнофункциональное управление процессами с помощью групп процессов FastCGI, совместно использующих сокеты, без привязки к конкретному веб-серверу. Это четкое разделение задач, позволяющее веб-серверу и диспетчеру процессов делать то, что у них получается лучше всего.

{% hint style="info" %}
Диспетчер сокетов в Supervisor изначально был разработан для поддержки процессов FastCGI, но не ограничивается FastCGI. Другие протоколы также могут использоваться без специальной настройки. Любая программа, которая может получить доступ к открытому сокету из файлового дескриптора (например, с помощью [socket.fromfd](http://docs.python.org/library/socket.html#socket.fromfd) в Python), может использовать диспетчер сокетов. Supervisor автоматически создаст сокет, привяжет и прослушает перед разветвлением первого дочернего элемента в группе. Сокет будет передан каждому дочернему элементу с файловым дескриптором номер `0` (ноль). Когда последний дочерний процесс  в группе выйдет, Supervisor закроет сокет.
{% endhint %}

{% hint style="info" %}
До Supervisor 3.4.0 на программы FastCGI (**\[fcgi-program:x]**) нельзя было ссылаться в группах (**\[group:x]**).
{% endhint %}

Все параметры, доступные для разделов `[program:x]`, также учитываются разделами **fcgi-program**.

### Секция значений `[fcgi-program:x]`

Разделы `[fcgi-program:x]` имеют несколько ключей, которых нет в разделах `[program:x]`.

**`socket`**

Сокет FastCGI для этой программы, сокет домена TCP или UNIX. Для сокетов TCP используйте следующий формат: `tcp://localhost:9002`. Для сокетов домена UNIX используйте `unix:///absolute/path/to/file.sock`. Строковые выражения оцениваются по словарю, содержащему ключи `«program_name»` и `«here»` (каталог файла конфигурации **supervisord**).

_По умолчанию_: Нет значения по умолчанию

_Требуется_: Да.

_Введено_: 3.0

**`socket_backlog`**

Устанавливает backlog сокета listen(2).

_По умолчанию_: SOMAXCONN

_Требуется_: Нет.

_Введено_: 3.4.0

**`socket_owner`**

Для сокетов домена UNIX этот параметр можно использовать для указания пользователя и группы для сокета FastCGI. Может быть именем пользователя UNIX (например, **chrism**) или именем пользователя UNIX и группой, разделенными двоеточием (например, **chrism:wheel**).

_По умолчанию_: Использует набор пользователей и групп для **fcgi-program**

_Требуется_: Нет.

_Введено_: 3.0

**`socket_mode`**

Для сокетов домена UNIX этот параметр можно использовать для указания режима разрешений.

_По умолчанию_: `0700`

_Требуется_: Нет.

_Введено_: 3.0

Обратитесь к [настройкам раздела \[program:x\]](konfiguracionnyi-fail.md#nastroiki-razdela-program-x) для получения информации о других допустимых ключах, измените вышеуказанные ограничения и дополнения.

### Пример секции `[fcgi-program:x]`

```ini
[fcgi-program:fcgiprogramname]
command=/usr/bin/example.fcgi
socket=unix:///var/run/supervisor/%(program_name)s.sock
socket_owner=chrism
socket_mode=0700
process_name=%(program_name)s_%(process_num)02d
numprocs=5
directory=/tmp
umask=022
priority=999
autostart=true
autorestart=unexpected
startsecs=1
startretries=3
exitcodes=0
stopsignal=QUIT
stopasgroup=false
killasgroup=false
stopwaitsecs=10
user=chrism
redirect_stderr=true
stdout_logfile=/a/path
stdout_logfile_maxbytes=1MB
stdout_logfile_backups=10
stdout_events_enabled=false
stderr_logfile=/a/path
stderr_logfile_maxbytes=1MB
stderr_logfile_backups=10
stderr_events_enabled=false
environment=A="1",B="2"
serverurl=AUTO
```

## Настройки раздела `[eventlistener:x]`

Supervisor позволяет определять специализированные однородные группы процессов («пулы прослушивателей событий») в файле конфигурации. Эти пулы содержат процессы, которые предназначены для получения и ответа на уведомления о событиях из системы событий supervisor. См. <mark style="color:purple;">События</mark> для объяснения того, как работают события и как реализовать программы, которые могут быть объявлены как прослушиватели событий.

Обратите внимание, что все параметры, доступные для разделов `[program:x]`, учитываются разделами прослушивателя событий, за исключением **stdout\_capture\_maxbytes**. Прослушиватели событий не могут генерировать события связи процесса на стандартный вывод **stdout**, но могут генерировать на **stderr** (см. <mark style="color:purple;">Режим захвата</mark>).

### Секция значений `[eventlistener:x]`

Разделы `[eventlistener:x]` имеют несколько ключей, которых нет в разделах `[program:x]`.

**`buffer_size`**

Размер буфера очереди событий пула прослушивателей событий. Когда буфер событий пула прослушивателей переполняется (что может случиться, когда пул прослушивателей событий не справляется со всеми отправленными ему событиями), самое старое событие в буфере отбрасывается.

**`events`**

Список разделенных запятыми имен типов событий, для которых этот слушатель «заинтересован» в получении уведомлений (см. <mark style="color:purple;">Типы событий</mark> для списка допустимых имен типов событий).

**`result_handler`**

[Строка точки входа pkg\_resources](http://peak.telecommunity.com/DevCenter/PkgResources), которая разрешается в вызываемый объект Python. Значение по умолчанию — `supervisor.dispatchers:default_handler`. Указание альтернативного обработчика результатов — очень редкая вещь, и в результате способ его создания не задокументирован.

Обратитесь к [настройкам раздела \[program:x\]](konfiguracionnyi-fail.md#nastroiki-razdela-program-x) для получения информации о других допустимых ключах, измените вышеуказанные ограничения и дополнения.

### Пример секции `[eventlistener:x]`

```ini
[eventlistener:theeventlistenername]
command=/bin/eventlistener
process_name=%(program_name)s_%(process_num)02d
numprocs=5
events=PROCESS_STATE
buffer_size=10
directory=/tmp
umask=022
priority=-1
autostart=true
autorestart=unexpected
startsecs=1
startretries=3
exitcodes=0
stopsignal=QUIT
stopwaitsecs=10
stopasgroup=false
killasgroup=false
user=chrism
redirect_stderr=false
stdout_logfile=/a/path
stdout_logfile_maxbytes=1MB
stdout_logfile_backups=10
stdout_events_enabled=false
stderr_logfile=/a/path
stderr_logfile_maxbytes=1MB
stderr_logfile_backups=10
stderr_events_enabled=false
environment=A="1",B="2"
serverurl=AUTO
```

## Настройки раздела `[rpcinterface:x]`

Добавление параметров **rpcinterface:x** в файл конфигурации полезно только для тех, кто хочет расширить супервизора дополнительным пользовательским поведением.

В образце файла конфигурации (см. [Создание файла конфигурации](ustanovka-supervisor.md#sozdanie-faila-konfiguracii)) есть раздел с именем `[rpcinterface:supervisor]`. По умолчанию это выглядит следующим образом.

```ini
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface
```

Раздел `[rpcinterface:supervisor]` должен оставаться в конфигурации, чтобы стандартная настройка супервизора работала правильно. Если вы не хотите, чтобы супервизор делал что-то, чего он еще не делает по умолчанию, это все, что вам нужно знать об этом типе раздела.

Однако, если вы хотите добавить пространства имен интерфейса rpc для настройки супервизора, вы можете добавить дополнительные разделы `[rpcinterface:foo]`, где «foo» представляет пространство имен интерфейса (из корня веб-сайта), а значение, названное `supervisor.rpcinterface_factory` — это вызываемая фабрика, которая должна иметь сигнатуру функции, которая принимает один позиционный аргумент **supervisord** и столько аргументов ключевого слова, сколько требуется для выполнения конфигурации. Любые дополнительные пары ключ/значение, определенные в разделе `[rpcinterface:x]`, будут переданы фабрике в качестве аргументов ключевого слова.

Вот пример фабричной функции, созданной в файле `__init__.py` пакета Python `my.package`.

```python
from my.package.rpcinterface import AnotherRPCInterface

def make_another_rpcinterface(supervisord, **config):
    retries = int(config.get('retries', 0))
    another_rpc_interface = AnotherRPCInterface(supervisord, retries)
    return another_rpc_interface
```

И раздел в файле конфигурации, предназначенный для его настройки.

```ini
[rpcinterface:another]
supervisor.rpcinterface_factory = my.package:make_another_rpcinterface
retries = 1
```

### Секция значений `[rpcinterface:x]`

**`supervisor.rpcinterface_factory`**

**pkg\_resources** «точка входа» с точкой для фабричной функции вашего интерфейса RPC.

_По умолчанию_: Не определено

_Требуется_: Нет.

_Введено_: 3.0

### Пример секции `[rpcinterface:x]`

```ini
[rpcinterface:another]
supervisor.rpcinterface_factory = my.package:make_another_rpcinterface
retries = 1
```
