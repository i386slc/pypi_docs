# События supervisor

События — это расширенная функция Supervisor, представленная в версии 3.0. Вам не нужно понимать события, если вы просто хотите использовать Supervisor как механизм для перезапуска аварийных процессов или как систему для ручного управления состоянием процесса. Вам необходимо понимать события, если вы хотите использовать Supervisor как часть системы мониторинга/уведомления процессов.

## Слушатели событий и уведомления о событиях

Supervisor предоставляет специально написанной программе (которую он запускает как подпроцесс), называемой «слушателем событий» (_event listener_), возможность подписываться на «уведомления о событиях» (_event notifications_). Уведомление о событии подразумевает, что произошло что-то, связанное с подпроцессом, контролируемым **supervisord**, или с самим **supervisord**. Уведомления о событиях сгруппированы по типам, чтобы прослушиватели событий могли подписаться на ограниченное подмножество уведомлений о событиях. Supervisor постоянно отправляет уведомления о событиях во время работы, даже если прослушиватели не настроены. Если прослушиватель настроен и подписан на тип события, который генерируется в течение времени жизни **supervisord**, этот прослушиватель будет уведомлен.

Цель системы уведомления/подписки о событии — предоставить механизм запуска произвольного кода (например, отправить электронное письмо, сделать HTTP-запрос и т. д.) при выполнении некоторого условия. Это условие обычно связано с состоянием подпроцесса. Например, вы можете захотеть уведомить кого-либо по электронной почте о сбое процесса и его перезапуске Supervisor.

Протокол уведомления о событиях основан на обмене данными через стандартный ввод и стандартный вывод подпроцесса. Supervisor отправляет специально отформатированные входные данные на стандартный ввод процесса прослушивателя событий и ожидает специально отформатированные выходные данные из стандартного вывода прослушивателя событий, формируя цикл запрос-ответ. Протокол, согласованный между супервизором и исполнителем слушателя, позволяет слушателям обрабатывать уведомления о событиях. Прослушиватели событий могут быть написаны на любом языке, поддерживаемом платформой, которую вы используете для запуска Supervisor. Хотя прослушиватели событий могут быть написаны на любом языке, для Python существует специальная поддержка библиотек в виде модуля `supervisor.childutils`, что делает создание прослушивателей событий на Python немного проще, чем на других языках.

### Настройка прослушивателя событий

Прослушиватель событий супервизора указывается в разделе `[eventlistener:x]` в файле конфигурации. Секции супервизора `[eventlistener:x]` обрабатываются почти так же, как секция супервизора `[program:x]` в отношении ключей, разрешенных в их конфигурации, за исключением того, что супервизор не учитывает вывод «режим захвата» из процессов прослушивателя событий (т. е. прослушиватели событий не могут быть генераторами событий **PROCESS\_COMMUNICATIONS\_EVENT**). Поэтому указывать **stdout\_capture\_maxbytes** или **stderr\_capture\_maxbytes** в конфигурации прослушивателя событий является ошибкой. Нет никаких искусственных ограничений на количество разделов прослушивателя событий, которые можно поместить в файл конфигурации.

Когда определен раздел `[eventlistener:x]`, он фактически определяет «пул», в котором количество прослушивателей событий в пуле определяется значением **numprocs** в разделе.

Параметр **events** раздела `[eventlistener:x]` указывает события, которые будут отправлены в пул слушателей. Хорошо написанный прослушиватель событий будет игнорировать события, которые он не может обработать, но нет гарантии, что конкретный прослушиватель событий не выйдет из строя в результате получения события типа, который он не может обработать. Поэтому, в зависимости от реализации прослушивателя, может быть важно указать в конфигурации, что он может получать только определенные типы событий. Разработчик прослушивателя событий — единственный человек, который может сказать вам, что это такое (и, следовательно, какое значение нужно указать в конфигурации **events**). Ниже приведены примеры конфигураций прослушивателя событий, которые можно разместить в файле `supervisord.conf`.

```ini
[eventlistener:memmon]
command=memmon -a 200MB -m bob@example.com
events=TICK_60
```

```ini
[eventlistener:mylistener]
command=my_custom_listener.py
events=PROCESS_STATE,TICK_60
```

{% hint style="info" %}
Расширенная функция, определяющая альтернативный «обработчик результатов» (_result handler_) для пула, может быть указана через параметр **result\_handler** секции **\[eventlistener:x]** в виде строки «точки входа» **pkg\_resources**. Обработчик результатов по умолчанию — `supervisord.dispatchers:default_handler`. Создание альтернативного обработчика результатов в настоящее время не документировано.
{% endhint %}

Когда супервизор отправляет уведомление о событии, будут найдены все пулы прослушивателей событий, которые подписаны на получение событий для типа события (отфильтрованного по значению **events** в разделе прослушивателя событий). Один из слушателей в каждом пуле слушателей получит уведомление о событии (любой «доступный» слушатель).

Каждый процесс в пуле прослушивателей событий одинаково обрабатывается супервизором. Если процесс в пуле недоступен (из-за того, что он уже обрабатывает событие, из-за сбоя или из-за того, что он решил удалить себя из пула), супервизор выберет другой процесс из пула. Если событие не может быть отправлено из-за того, что все прослушиватели в пуле «заняты» (_busy_), событие будет помещено в буфер, а уведомление будет отправлено позже. «Позже» определяется как «в следующий раз, когда будет выполняться цикл выбора **supervisord**». Для удовлетворительной производительности обработки событий следует настроить пул с таким количеством процессов прослушивания событий, которое необходимо для обработки вашей нагрузки событий. Это можно определить только эмпирически для любой данной рабочей нагрузки, «магического числа» не существует, но чтобы помочь вам определить оптимальное количество слушателей в заданном пуле, Supervisor будет выдавать предупреждающие сообщения в свой журнал активности, когда событие не может быть отправлено немедленно из-за к перегруженности пула. Нет никаких искусственных ограничений на количество процессов, которые могут быть в пуле, оно ограничено только ограничениями вашей платформы.

Пул слушателей имеет очередь буфера событий. Размер очереди определяется с помощью параметра файла конфигурации **buffer\_size** пула слушателей. Если очередь заполнена и супервизор пытается буферизовать событие, супервизор отбрасывает самое старое событие в буфере и регистрирует ошибку.

### Написание прослушивателя событий

Реализация прослушивателя событий — это программа, которая готова принимать структурированный ввод в своем потоке **stdin** и создавать структурированный вывод в своем потоке **stdout**. Реализация прослушивателя событий должна работать в «небуферизованном» режиме или должна сбрасывать свой стандартный вывод каждый раз, когда ему необходимо связаться с процессом **supervisord**. Слушатели событий могут быть написаны как долго работающие или могут завершаться после одного запроса (в зависимости от реализации и параметра **autorestart** в конфигурации прослушивателя событий).

Прослушиватель событий может отправлять произвольные выходные данные на свой **stderr**, которые будут зарегистрированы или проигнорированы **supervisord** в зависимости от конфигурации файла журнала, связанного с **stderr**, в его разделе `[eventlistener:x]`.

### Протокол уведомления о событиях

Когда **supervisord** отправляет уведомление процессу прослушивателя событий, прослушивателю сначала будет отправлена одна строка «header» на его стандартный ввод. Состав строки представляет собой набор токенов, разделенных двоеточием (каждый из которых представляет пару ключ-значение), отделенных друг от друга одним пробелом. Строка завершается символом `\n` (перевод строки). Токены на линии не гарантируются в каком-либо определенном порядке. Определенные в настоящее время типы токенов приведены в таблице ниже.

<table><thead><tr><th width="133">Ключ</th><th>Описание</th></tr></thead><tbody><tr><td>ver</td><td>Версия протокола системы событий</td></tr><tr><td>server</td><td>Идентификатор <strong>supervisord</strong>, отправляющего событие (см. значение <strong>identifier</strong> раздела <code>[supervisord]</code> файла конфигурации.</td></tr><tr><td>serial</td><td>Целое число, присвоенное каждому событию. Никакие два события, сгенерированные во время жизни контролируемого процесса, не будут иметь одинаковый порядковый номер. Это значение полезно для функционального тестирования и обнаружения аномалий порядка событий.</td></tr><tr><td>pool</td><td>Имя пула прослушивателей событий, сгенерировавшего это событие.</td></tr><tr><td>poolserial</td><td>Целое число, присваиваемое каждому событию пулом прослушивателей событий, из которого оно отправляется. Никакие два события, сгенерированные одним и тем же пулом прослушивателей событий в течение жизни процесса <strong>supervisord</strong>, не будут иметь одинаковый <strong>poolserial</strong> пула. Это значение можно использовать для обнаружения аномалий порядка следования событий.</td></tr><tr><td>eventname</td><td>Имя конкретного типа события (см. <a href="sobytiya-supervisor.md#tipy-sobytii">Типы событий</a>)</td></tr><tr><td>len</td><td>Целое число, указывающее количество байтов в полезной нагрузке события, также известное как <strong>PAYLOAD_LENGTH</strong>.</td></tr></tbody></table>

Пример полной строки заголовка выглядит следующим образом.

```
ver:3.0 server:supervisor serial:21 pool:listener poolserial:10 eventname:PROCESS_COMMUNICATION_STDOUT len:54
```

Сразу после символа перевода строки в заголовке идет полезная нагрузка события. Он состоит из байтов **PAYLOAD\_LENGTH**, представляющих сериализацию данных события. См. [Типы событий](sobytiya-supervisor.md#tipy-sobytii) для конкретных определений сериализации данных событий.

Ниже приведен пример полезной нагрузки для уведомления о событии **PROCESS\_COMMUNICATION\_STDOUT**.

```
processname:foo groupname:bar pid:123
This is the data that was sent between the tags
```

Структура полезной нагрузки любого данного события определяется только типом события.

### Состояния прослушивателя событий

Процесс слушателя событий имеет три возможных состояния, которые поддерживаются **supervisord**:

<table><thead><tr><th width="196">Название</th><th>Описание</th></tr></thead><tbody><tr><td>ACKNOWNLEDGED</td><td>Прослушиватель событий подтвердил (принял или отклонил) отправку события.</td></tr><tr><td>READY</td><td>Уведомления о событиях могут быть отправлены на этот прослушиватель событий</td></tr><tr><td>BUSY</td><td>Уведомления о событиях не могут быть отправлены этому прослушивателю событий.</td></tr></tbody></table>

Когда процесс прослушивателя событий запускается впервые, супервизор автоматически переводит его в состояние **ACKNOWNLEDGED**, чтобы разрешить действия при запуске или предотвратить сбои запуска (зависания). Пока прослушиватель не отправит строку `READY\n` на свой стандартный вывод, он останется в этом состоянии.

Когда супервизор отправляет уведомление о событии слушателю в состоянии **READY**, слушатель будет переведен в состояние **BUSY** до тех пор, пока не получит от слушателя ответ **OK** или **FAIL**, после чего прослушиватель будет переведен обратно в состояние **ACKNOWLEDGED**.

### Протокол уведомления прослушивателя событий

Супервизор уведомляет прослушиватель событий в состоянии **READY** о событии, отправляя данные на стандартный ввод процесса. Supervisor никогда не будет отправлять что-либо на стандартный ввод процесса прослушивателя событий, пока этот процесс находится в состоянии **BUSY** или **ACKNOWLEDGED**. Супервизор начинает с отправки заголовка.

После обработки заголовка реализация прослушивателя событий должна считать байты **PAYLOAD\_LENGTH** из своего стандартного ввода, выполнить произвольное действие на основе значений в заголовке и данных, проанализированных из сериализации. При этом можно заблокировать на произвольное время. Supervisor продолжит обычную обработку, ожидая ответа, и по мере необходимости будет отправлять другие события того же типа другим процессам прослушивателя в том же пуле.

После того, как прослушиватель событий обработает сериализацию события, чтобы уведомить супервизор о результате, он должен отправить структуру результата на свой стандартный вывод. Структура результата — это слово `"RESULT"`, за которым следует пробел, за которым следует длина результата, за которым следует перевод строки, за которым следует содержимое результата. Например, `RESULT 2\nОК` — это результат «ОК». Обычно прослушиватель событий будет использовать либо **OK**, либо **FAIL** в качестве содержимого результата. Эти строки имеют особое значение для обработчика результатов по умолчанию.

Если обработчик результатов по умолчанию получает **OK** в качестве содержимого результата, он будет считать, что прослушиватель успешно обработал уведомление о событии. Если он получает **FAIL**, он предполагает, что прослушиватель не смог обработать событие, и событие будет повторно буферизовано и отправлено позже. Прослушиватель событий может отклонить событие по любой причине, вернув результат **FAIL**. Это не указывает на проблему с данными события или прослушивателем событий. Как только супервизор получает результат **OK** или **FAIL**, прослушиватель событий переходит в состояние **ACKNOWLEDGED**.

Как только прослушиватель находится в состоянии **ACKNOWLEDGED**, он может либо выйти (и впоследствии может быть перезапущен супервизором, если его параметр конфигурации **autorestart** равен **true**), либо продолжить работу. Если он продолжает работать, то для того, чтобы супервизор снова перевел его в состояние **READY**, он должен отправить токен **READY**, за которым сразу следует перевод строки, на стандартный вывод.

### Пример реализации прослушивателя событий

Реализация Python «длительного» прослушивателя событий, который принимает уведомление о событии, печатает заголовок и полезную нагрузку в свой **stderr** и отвечает результатом **OK**, а затем **READY**, выглядит следующим образом.

```python
import sys

def write_stdout(s):
    # только сообщения протокола eventlistener могут быть отправлены
    # на стандартный вывод
    sys.stdout.write(s)
    sys.stdout.flush()

def write_stderr(s):
    sys.stderr.write(s)
    sys.stderr.flush()

def main():
    while 1:
        # переход от ACKNOWLEDGED к READY
        write_stdout('READY\n')

        # читает строку заголовка и печатает ее в stderr
        line = sys.stdin.readline()
        write_stderr(line)

        # читает полезную нагрузку события и печатает ее в stderr
        headers = dict([ x.split(':') for x in line.split() ])
        data = sys.stdin.read(int(headers['len']))
        write_stderr(data)

        # переход от READY к ACKNOWLEDGED
        write_stdout('RESULT 2\nOK')

if __name__ == '__main__':
    main()
```

В пакете [Superlance](http://supervisord.org/glossary.html#term-Superlance) присутствуют другие примеры слушателей событий, в том числе тот, который может отслеживать подпроцессы супервизора и перезапускать процесс, если он использует «слишком много» памяти.

### Условия ошибки прослушивателя событий

Если процесс прослушивателя событий завершается во время передачи события на его стандартный ввод или если он прекращает работу до отправки структуры результата обратно в **supervisord**, считается, что событие не было обработано, и оно будет повторно буферизовано **supervisord** и отправлено позже.

Если прослушиватель событий отправляет на свой стандартный вывод данные, которые супервизор не распознает как подходящий ответ на основе состояния, в котором находится прослушиватель событий, прослушиватель событий будет переведен в состояние **UNKNOWN**, и ему больше не будут отправляться уведомления о событиях. Если в это время прослушиватель обрабатывал событие, оно будет повторно буферизовано и отправлено позже.

### Разное

Прослушиватели событий могут использовать интерфейс Supervisor XML-RPC для обратного вызова Supervisor. Таким образом, прослушиватели событий могут влиять на состояние подпроцесса Supervisor в результате получения уведомления о событии. Например, вы можете захотеть генерировать событие каждые несколько минут, связанное с использованием подпроцессов, контролируемых супервизором, и если какой-либо из этих процессов превышает некоторый порог памяти, вы хотели бы перезапустить его. Вы должны написать программу, которая заставит супервизор время от времени генерировать события **PROCESS\_COMMUNICATION** с информацией о памяти в них, а прослушиватель событий будет выполнять действие на основе обработки данных, которые он получает от этих событий.

## Типы событий

Типы событий представляют собой контролируемый набор, определяемый самим Supervisor. Невозможно добавить тип события без изменения самого **supervisord**. Однако обычно это не проблема, поскольку к событиям присоединяются метаданные, которые могут использоваться прослушивателями событий в качестве дополнительного критерия фильтрации в сочетании с их типом.

Типы событий, на которые могут подписаться прослушиватели событий, предварительно определяются супервизором и делятся на несколько основных категорий, включая события `“process state change”`, `“process communication”` и `“supervisor state change”`. Ниже приведены таблицы с описанием этих типов событий.

В приведенном ниже списке мы указываем, что некоторые типы событий имеют тело `"body"`, которое представляет собой набор токенов. Набор токенов состоит из набора символов с токенами, разделенными пробелами. Каждый токен представляет собой пару ключ-значение. Ключ и значение разделяются двоеточием. Например:

```
processname:cat groupname:cat from_state:STOPPED
```

Наборы токенов не имеют в конце символа перевода строки или возврата каретки.

### EVENT

Базовый тип события. Этот тип события является абстрактным. Он никогда не будет отправлен напрямую. Подписка на этот тип события приведет к тому, что подписчик будет получать все уведомления о событиях, отправляемые Supervisor.

_Название_: EVENT.

_Подтип типа_: N/A.

_Описание тела_: N/A

### PROCESS\_STATE

Этот тип процесса указывает, что процесс перешел из одного состояния в другое. См. «[Состояния процесса](subprocessy.md#sostoyaniya-processa)» для описания состояний, через которые проходит процесс в течение своего жизненного цикла. Этот тип события является абстрактным, он никогда не будет отправлен напрямую. Подписка на этот тип события приведет к тому, что подписчик будет получать уведомления о событиях всех типов событий, являющихся подтипами **PROCESS\_STATE**.

_Название_: PROCESS\_STATE.

_Подтип типа_: EVENT.

**Описание тела**

Все подтипы **PROCESS\_STATE** имеют тело, которое представляет собой набор токенов. Кроме того, каждый набор токенов подтипа **PROCESS\_STATE** имеет набор пар ключ/значение по умолчанию: **processname**, **groupname** и **from\_state**. **processname** представляет собой имя процесса, под которым супервизор знает этот процесс. **groupname** представляет собой имя группы супервизора, в которой находится этот процесс. **from\_state** — это имя состояния, из которого этот процесс переходит (новое состояние подразумевается конкретным типом события). Конкретные подтипы могут включать дополнительные пары ключ/значение в набор токенов.

### PROCESS\_STATE\_STARTING

Указывает, что процесс перешел из состояния в состояние **STARTING**.

_Название_: PROCESS\_STATE\_STARTING.

_Подтип типа_: PROCESS\_STATE.

**Описание тела**

Это тело представляет собой набор токенов. Он имеет набор пар ключ/значение по умолчанию, а также дополнительный ключ **tries**. **tries** представляет количество раз, когда этот процесс входил в это состояние перед переходом в **RUNNING** или **FATAL** (оно никогда не будет больше, чем параметр **startretries** процесса). Например:

```
processname:cat groupname:cat from_state:STOPPED tries:0
```

### PROCESS\_STATE\_RUNNING

Указывает, что процесс перешел из состояния **STARTING** в состояние **RUNNING**. Это означает, что процесс успешно начался с точки зрения супервизора.

_Название_: PROCESS\_STATE\_RUNNING.

_Подтип типа_: PROCESS\_STATE.

**Описание тела**

Это тело представляет собой набор токенов. Он имеет набор пар ключ/значение по умолчанию, а также дополнительный ключ **pid**. **pid** представляет собой идентификатор запущенного процесса UNIX. Например:

```
processname:cat groupname:cat from_state:STARTING pid:2766
```

### PROCESS\_STATE\_BACKOFF

Указывает, что процесс перешел из состояния **STARTING** в состояние **BACKOFF**. Это означает, что процесс не успешно перешел в состояние **RUNNING**, и Supervisor попытается перезапустить его, если только он не превысил свой предел конфигурации `"startretries"`.

_Название_: PROCESS\_STATE\_BACKOFF.

_Подтип типа_: PROCESS\_STATE.

**Описание тела**

Это тело представляет собой набор токенов. Он имеет набор пар ключ/значение по умолчанию, а также дополнительный ключ **tries**. **tries** представляет количество раз, когда этот процесс входил в это состояние перед переходом в **RUNNING** или **FATAL** (оно никогда не будет больше, чем параметр **startretries** процесса). Например:

```
processname:cat groupname:cat from_state:STOPPED tries:0
```

### PROCESS\_STATE\_STOPPING

Указывает, что процесс перешел из состояния **RUNNING** или **STARTING** в состояние **STOPPING**.

_Название_: PROCESS\_STATE\_STOPPING.

_Подтип типа_: PROCESS\_STATE.

**Описание тела**

Это тело представляет собой набор токенов. Он имеет набор пар ключ/значение по умолчанию, а также дополнительный ключ **pid**. **pid** представляет собой идентификатор запущенного процесса UNIX. Например:

```
processname:cat groupname:cat from_state:STARTING pid:2766
```

### PROCESS\_STATE\_EXITED

Указывает, что процесс перешел из состояния **RUNNING** в состояние **EXITED**.

_Название_: PROCESS\_STATE\_EXITED.

_Подтип типа_: PROCESS\_STATE.

**Описание тела**

Это тело представляет собой набор токенов. Он имеет набор пар ключ/значение по умолчанию, а также два дополнительных ключа: **pid** и **expected**. **pid** представляет собой идентификатор завершившегося процесса UNIX. **expected** представляет, завершился ли процесс с ожидаемым кодом выхода или нет. Будет `0`, если код выхода был неожиданным, или `1`, если код выхода ожидался. Например:

```
processname:cat groupname:cat from_state:RUNNING expected:0 pid:2766
```

### PROCESS\_STATE\_STOPPED

Указывает, что процесс перешел из состояния **STOPPING** в состояние **STOPPED**.

_Название_: PROCESS\_STATE\_STOPPED.

_Подтип типа_: PROCESS\_STATE.

**Описание тела**

Это тело представляет собой набор токенов. Он имеет набор пар ключ/значение по умолчанию, а также дополнительный ключ **pid**. **pid** представляет собой идентификатор запущенного процесса UNIX. Например:

```
processname:cat groupname:cat from_state:STOPPING pid:2766
```

### PROCESS\_STATE\_FATAL

Указывает, что процесс перешел из состояния **BACKOFF** в состояние **FATAL**. Это означает, что Supervisor несколько раз безуспешно пытался **startretries** запустить процесс и отказался от попыток перезапустить его.

_Название_: PROCESS\_STATE\_FATAL.

_Подтип типа_: PROCESS\_STATE.

**Описание тела**

Этот тип события представляет собой набор токенов с парами ключ/значение по умолчанию. Например:

```
processname:cat groupname:cat from_state:BACKOFF
```

### PROCESS\_STATE\_UNKNOWN

Указывает, что процесс перешел из любого состояния в состояние **UNKNOWN** (указывает на ошибку в **supervisord**). Этот переход состояния произойдет только в том случае, если в самом **supervisord** возникла ошибка программирования.

_Название_: PROCESS\_STATE\_UNKNOWN.

_Подтип типа_: PROCESS\_STATE.

**Описание тела**

Этот тип события представляет собой набор токенов с парами ключ/значение по умолчанию. Например:

```
processname:cat groupname:cat from_state:BACKOFF
```

### REMOTE\_COMMUNICATION

Тип события, возникающий при вызове метода `supervisor.sendRemoteCommEvent()` в интерфейсе RPC супервизора. Тип **type** и данные **data** являются аргументами метода RPC.

_Название_: REMOTE\_COMMUNICATION.

_Подтип типа_: EVENT.

**Описание тела**

```
type:type
data
```

### PROCESS\_LOG

Тип события, возникающий, когда процесс записывает данные в **stdout** или **stderr**. Событие будет сгенерировано только в том случае, если дескриптор файла не находится в режиме захвата и если для параметров конфигурации **stdout\_events\_enabled** или **stderr\_events\_enabled** установлено значение **true**. Этот тип события является абстрактным, он никогда не будет отправлен напрямую. Подписка на этот тип события приведет к тому, что подписчик будет получать уведомления о событиях для всех подтипов **PROCESS\_LOG**.

_Название_: PROCESS\_LOG.

_Подтип типа_: EVENT.

_Описание тела_: N/A

### PROCESS\_LOG\_STDOUT

Указывает, что процесс выполнил запись в свой файловый дескриптор **stdout**. Событие будет сгенерировано только в том случае, если дескриптор файла не находится в режиме захвата и если для параметра конфигурации **stdout\_events\_enabled** установлено значение **true**.

_Название_: PROCESS\_LOG\_STDOUT.

_Подтип типа_: PROCESS\_LOG.

**Описание тела**

```
processname:name groupname:name pid:pid
data
```

### PROCESS\_LOG\_STDERR

Указывает, что процесс выполнил запись в свой файловый дескриптор **stderr**. Событие будет сгенерировано только в том случае, если дескриптор файла не находится в режиме захвата и если для параметра конфигурации **stderr\_events\_enabled** установлено значение **true**.

_Название_: PROCESS\_LOG\_STDERR.

_Подтип типа_: PROCESS\_LOG.

**Описание тела**

```
processname:name groupname:name pid:pid
data
```

### PROCESS\_COMMUNICATION

Тип события, возникающий, когда какой-либо процесс пытается отправить информацию между тегами `<!--XSUPERVISOR:BEGIN-->` и `<!--XSUPERVISOR:END-->` в своих выходных данных. Этот тип события является абстрактным, он никогда не будет отправлен напрямую. Подписка на этот тип события приведет к тому, что подписчик будет получать уведомления о событиях для всех подтипов **PROCESS\_COMMUNICATION**.

_Название_: PROCESS\_COMMUNICATION.

_Подтип типа_: EVENT.

_Описание тела_: N/A

### PROCESS\_COMMUNICATION\_STDOUT

Указывает, что процесс отправил сообщение Supervisor в своем файловом дескрипторе **stdout**.

_Название_: PROCESS\_COMMUNICATION\_STDOUT.

_Подтип типа_: PROCESS\_COMMUNICATION.

**Описание тела**

```
processname:name groupname:name pid:pid
data
```

### PROCESS\_COMMUNICATION\_STDERR

Указывает, что процесс отправил сообщение Supervisor в своем файловом дескрипторе **stderr**.

_Название_: PROCESS\_COMMUNICATION\_STDERR.

_Подтип типа_: PROCESS\_COMMUNICATION.

**Описание тела**

```
processname:name groupname:name pid:pid
data
```

### SUPERVISOR\_STATE\_CHANGE

Тип события, возникающий при изменении состояния контролируемого процесса **supervisord**. Этот тип является абстрактным, он никогда не будет отправлен напрямую. Подписка на этот тип события приведет к тому, что подписчик будет получать уведомления о событиях всех подтипов **SUPERVISOR\_STATE\_CHANGE**.

_Название_: SUPERVISOR\_STATE\_CHANGE.

_Подтип типа_: EVENT.

_Описание тела_: N/A

### SUPERVISOR\_STATE\_CHANGE\_RUNNING

Указывает, что **supervisord** запущен.

_Название_: SUPERVISOR\_STATE\_CHANGE\_RUNNING.

_Подтип типа_: SUPERVISOR\_STATE\_CHANGE.

_Описание тела_: пустая строка

### SUPERVISOR\_STATE\_CHANGE\_STOPPING

Указывает, что **supervisord** останавливается.

_Название_: SUPERVISOR\_STATE\_CHANGE\_STOPPING.

_Подтип типа_: SUPERVISOR\_STATE\_CHANGE.

_Описание тела_: пустая строка

### TICK

Тип события, на который можно подписаться, чтобы прослушиватели событий получали уведомления о пробуждении (_wake-up_) каждые N секунд. Этот тип события является абстрактным, он никогда не будет отправлен напрямую. Подписка на этот тип события приведет к тому, что подписчик будет получать уведомления о событиях для всех подтипов **TICK**.

Обратите внимание, что доступны только те события **TICK**, которые перечислены ниже. Вы не можете подписаться на произвольный интервал **TICK**. Если вам нужен интервал, не указанный ниже, вы можете подписаться на один из более коротких интервалов, указанных ниже, и отслеживать время между запусками в прослушивателе событий.

_Название_: TICK.

_Подтип типа_: EVENT.

_Описание тела_: N/A

### TICK\_5

Тип события, на который можно подписаться, чтобы прослушиватели событий получали уведомления о пробуждении каждые **5** секунд.

_Название_: TICK\_5.

_Подтип типа_: TICK.

**Описание тела**

Этот тип события представляет собой токен, установленный с одним ключом: `"when"`, который указывает время эпохи, для которого был отправлен тик.

```
when:1201063880
```

### TICK\_60

Тип события, на который можно подписаться, чтобы прослушиватели событий получали уведомления о пробуждении каждые **60** секунд.

_Название_: TICK\_60.

_Подтип типа_: TICK.

**Описание тела**

Этот тип события представляет собой токен, установленный с одним ключом: `"when"`, который указывает время эпохи, для которого был отправлен тик.

```
when:1201063880
```

### TICK\_3600

Тип события, на который можно подписаться, чтобы прослушиватели событий получали уведомления о пробуждении каждые **3600** секунд (1 час).

_Название_: TICK\_3600.

_Подтип типа_: TICK.

**Описание тела**

Этот тип события представляет собой токен, установленный с одним ключом: `"when"`, который указывает время эпохи, для которого был отправлен тик.

```
when:1201063880
```

### PROCESS\_GROUP

Тип события, возникающий при добавлении или удалении группы процессов в Supervisor. Этот тип является абстрактным, он никогда не будет отправлен напрямую. Подписка на этот тип события приведет к тому, что подписчик будет получать уведомления о событиях всех подтипов **PROCESS\_GROUP**.

_Название_: PROCESS\_GROUP.

_Подтип типа_: EVENT.

_Описание тела_: N/A

### PROCESS\_GROUP\_ADDED

Указывает, что группа процессов была добавлена в конфигурацию Supervisor.

_Название_: PROCESS\_GROUP\_ADDED.

_Подтип типа_: PROCESS\_GROUP.

_Описание тела_: Это тело представляет собой набор токенов только с ключом/значением имени группы.

```
groupname:cat
```

### PROCESS\_GROUP\_REMOVED

Указывает, что группа процессов была удалена из конфигурации Supervisor.

_Название_: PROCESS\_GROUP\_REMOVED.

_Подтип типа_: PROCESS\_GROUP.

_Описание тела_: Это тело представляет собой набор токенов только с ключом/значением имени группы.

```
groupname:cat
```
