# События supervisor

События — это расширенная функция Supervisor, представленная в версии 3.0. Вам не нужно понимать события, если вы просто хотите использовать Supervisor как механизм для перезапуска аварийных процессов или как систему для ручного управления состоянием процесса. Вам необходимо понимать события, если вы хотите использовать Supervisor как часть системы мониторинга/уведомления процессов.

## Слушатели событий и уведомления о событиях

Supervisor предоставляет специально написанной программе (которую он запускает как подпроцесс), называемой «слушателем событий» (_event listener_), возможность подписываться на «уведомления о событиях» (_event notifications_). Уведомление о событии подразумевает, что произошло что-то, связанное с подпроцессом, контролируемым **supervisord**, или с самим **supervisord**. Уведомления о событиях сгруппированы по типам, чтобы прослушиватели событий могли подписаться на ограниченное подмножество уведомлений о событиях. Supervisor постоянно отправляет уведомления о событиях во время работы, даже если прослушиватели не настроены. Если прослушиватель настроен и подписан на тип события, который генерируется в течение времени жизни **supervisord**, этот прослушиватель будет уведомлен.

Цель системы уведомления/подписки о событии — предоставить механизм запуска произвольного кода (например, отправить электронное письмо, сделать HTTP-запрос и т. д.) при выполнении некоторого условия. Это условие обычно связано с состоянием подпроцесса. Например, вы можете захотеть уведомить кого-либо по электронной почте о сбое процесса и его перезапуске Supervisor.

Протокол уведомления о событиях основан на обмене данными через стандартный ввод и стандартный вывод подпроцесса. Supervisor отправляет специально отформатированные входные данные на стандартный ввод процесса прослушивателя событий и ожидает специально отформатированные выходные данные из стандартного вывода прослушивателя событий, формируя цикл запрос-ответ. Протокол, согласованный между супервизором и исполнителем слушателя, позволяет слушателям обрабатывать уведомления о событиях. Прослушиватели событий могут быть написаны на любом языке, поддерживаемом платформой, которую вы используете для запуска Supervisor. Хотя прослушиватели событий могут быть написаны на любом языке, для Python существует специальная поддержка библиотек в виде модуля `supervisor.childutils`, что делает создание прослушивателей событий на Python немного проще, чем на других языках.

### Настройка прослушивателя событий

Прослушиватель событий супервизора указывается в разделе `[eventlistener:x]` в файле конфигурации. Секции супервизора `[eventlistener:x]` обрабатываются почти так же, как секция супервизора `[program:x]` в отношении ключей, разрешенных в их конфигурации, за исключением того, что супервизор не учитывает вывод «режим захвата» из процессов прослушивателя событий (т. е. прослушиватели событий не могут быть генераторами событий **PROCESS\_COMMUNICATIONS\_EVENT**). Поэтому указывать **stdout\_capture\_maxbytes** или **stderr\_capture\_maxbytes** в конфигурации прослушивателя событий является ошибкой. Нет никаких искусственных ограничений на количество разделов прослушивателя событий, которые можно поместить в файл конфигурации.

Когда определен раздел `[eventlistener:x]`, он фактически определяет «пул», в котором количество прослушивателей событий в пуле определяется значением **numprocs** в разделе.

Параметр **events** раздела `[eventlistener:x]` указывает события, которые будут отправлены в пул слушателей. Хорошо написанный прослушиватель событий будет игнорировать события, которые он не может обработать, но нет гарантии, что конкретный прослушиватель событий не выйдет из строя в результате получения события типа, который он не может обработать. Поэтому, в зависимости от реализации прослушивателя, может быть важно указать в конфигурации, что он может получать только определенные типы событий. Разработчик прослушивателя событий — единственный человек, который может сказать вам, что это такое (и, следовательно, какое значение нужно указать в конфигурации **events**). Ниже приведены примеры конфигураций прослушивателя событий, которые можно разместить в файле `supervisord.conf`.

```ini
[eventlistener:memmon]
command=memmon -a 200MB -m bob@example.com
events=TICK_60
```

```ini
[eventlistener:mylistener]
command=my_custom_listener.py
events=PROCESS_STATE,TICK_60
```

{% hint style="info" %}
Расширенная функция, определяющая альтернативный «обработчик результатов» (_result handler_) для пула, может быть указана через параметр **result\_handler** секции **\[eventlistener:x]** в виде строки «точки входа» **pkg\_resources**. Обработчик результатов по умолчанию — `supervisord.dispatchers:default_handler`. Создание альтернативного обработчика результатов в настоящее время не документировано.
{% endhint %}

Когда супервизор отправляет уведомление о событии, будут найдены все пулы прослушивателей событий, которые подписаны на получение событий для типа события (отфильтрованного по значению **events** в разделе прослушивателя событий). Один из слушателей в каждом пуле слушателей получит уведомление о событии (любой «доступный» слушатель).

Каждый процесс в пуле прослушивателей событий одинаково обрабатывается супервизором. Если процесс в пуле недоступен (из-за того, что он уже обрабатывает событие, из-за сбоя или из-за того, что он решил удалить себя из пула), супервизор выберет другой процесс из пула. Если событие не может быть отправлено из-за того, что все прослушиватели в пуле «заняты» (_busy_), событие будет помещено в буфер, а уведомление будет отправлено позже. «Позже» определяется как «в следующий раз, когда будет выполняться цикл выбора **supervisord**». Для удовлетворительной производительности обработки событий следует настроить пул с таким количеством процессов прослушивания событий, которое необходимо для обработки вашей нагрузки событий. Это можно определить только эмпирически для любой данной рабочей нагрузки, «магического числа» не существует, но чтобы помочь вам определить оптимальное количество слушателей в заданном пуле, Supervisor будет выдавать предупреждающие сообщения в свой журнал активности, когда событие не может быть отправлено немедленно из-за к перегруженности пула. Нет никаких искусственных ограничений на количество процессов, которые могут быть в пуле, оно ограничено только ограничениями вашей платформы.

Пул слушателей имеет очередь буфера событий. Размер очереди определяется с помощью параметра файла конфигурации **buffer\_size** пула слушателей. Если очередь заполнена и супервизор пытается буферизовать событие, супервизор отбрасывает самое старое событие в буфере и регистрирует ошибку.

### Написание прослушивателя событий

Реализация прослушивателя событий — это программа, которая готова принимать структурированный ввод в своем потоке **stdin** и создавать структурированный вывод в своем потоке **stdout**. Реализация прослушивателя событий должна работать в «небуферизованном» режиме или должна сбрасывать свой стандартный вывод каждый раз, когда ему необходимо связаться с процессом **supervisord**. Слушатели событий могут быть написаны как долго работающие или могут завершаться после одного запроса (в зависимости от реализации и параметра **autorestart** в конфигурации прослушивателя событий).

Прослушиватель событий может отправлять произвольные выходные данные на свой **stderr**, которые будут зарегистрированы или проигнорированы **supervisord** в зависимости от конфигурации файла журнала, связанного с **stderr**, в его разделе `[eventlistener:x]`.

### Протокол уведомления о событиях

Когда **supervisord** отправляет уведомление процессу прослушивателя событий, прослушивателю сначала будет отправлена одна строка «header» на его стандартный ввод. Состав строки представляет собой набор токенов, разделенных двоеточием (каждый из которых представляет пару ключ-значение), отделенных друг от друга одним пробелом. Строка завершается символом `\n` (перевод строки). Токены на линии не гарантируются в каком-либо определенном порядке. Определенные в настоящее время типы токенов приведены в таблице ниже.

<table><thead><tr><th width="133">Ключ</th><th>Описание</th></tr></thead><tbody><tr><td>ver</td><td>Версия протокола системы событий</td></tr><tr><td>server</td><td>Идентификатор <strong>supervisord</strong>, отправляющего событие (см. значение <strong>identifier</strong> раздела <code>[supervisord]</code> файла конфигурации.</td></tr><tr><td>serial</td><td>Целое число, присвоенное каждому событию. Никакие два события, сгенерированные во время жизни контролируемого процесса, не будут иметь одинаковый порядковый номер. Это значение полезно для функционального тестирования и обнаружения аномалий порядка событий.</td></tr><tr><td>pool</td><td>Имя пула прослушивателей событий, сгенерировавшего это событие.</td></tr><tr><td>poolserial</td><td>Целое число, присваиваемое каждому событию пулом прослушивателей событий, из которого оно отправляется. Никакие два события, сгенерированные одним и тем же пулом прослушивателей событий в течение жизни процесса <strong>supervisord</strong>, не будут иметь одинаковый <strong>poolserial</strong> пула. Это значение можно использовать для обнаружения аномалий порядка следования событий.</td></tr><tr><td>eventname</td><td>Имя конкретного типа события (см. <a href="sobytiya-supervisor.md#tipy-sobytii">Типы событий</a>)</td></tr><tr><td>len</td><td>Целое число, указывающее количество байтов в полезной нагрузке события, также известное как <strong>PAYLOAD_LENGTH</strong>.</td></tr></tbody></table>

Пример полной строки заголовка выглядит следующим образом.

```
ver:3.0 server:supervisor serial:21 pool:listener poolserial:10 eventname:PROCESS_COMMUNICATION_STDOUT len:54
```

Сразу после символа перевода строки в заголовке идет полезная нагрузка события. Он состоит из байтов **PAYLOAD\_LENGTH**, представляющих сериализацию данных события. См. [Типы событий](sobytiya-supervisor.md#tipy-sobytii) для конкретных определений сериализации данных событий.

Ниже приведен пример полезной нагрузки для уведомления о событии **PROCESS\_COMMUNICATION\_STDOUT**.

```
processname:foo groupname:bar pid:123
This is the data that was sent between the tags
```

Структура полезной нагрузки любого данного события определяется только типом события.

### Состояния прослушивателя событий

Процесс слушателя событий имеет три возможных состояния, которые поддерживаются **supervisord**:

<table><thead><tr><th width="196">Название</th><th>Описание</th></tr></thead><tbody><tr><td>ACKNOWNLEDGED</td><td>Прослушиватель событий подтвердил (принял или отклонил) отправку события.</td></tr><tr><td>READY</td><td>Уведомления о событиях могут быть отправлены на этот прослушиватель событий</td></tr><tr><td>BUSY</td><td>Уведомления о событиях не могут быть отправлены этому прослушивателю событий.</td></tr></tbody></table>

Когда процесс прослушивателя событий запускается впервые, супервизор автоматически переводит его в состояние **ACKNOWNLEDGED**, чтобы разрешить действия при запуске или предотвратить сбои запуска (зависания). Пока прослушиватель не отправит строку `READY\n` на свой стандартный вывод, он останется в этом состоянии.

Когда супервизор отправляет уведомление о событии слушателю в состоянии **READY**, слушатель будет переведен в состояние **BUSY** до тех пор, пока не получит от слушателя ответ **OK** или **FAIL**, после чего прослушиватель будет переведен обратно в состояние **ACKNOWLEDGED**.

### Протокол уведомления прослушивателя событий

Супервизор уведомляет прослушиватель событий в состоянии **READY** о событии, отправляя данные на стандартный ввод процесса. Supervisor никогда не будет отправлять что-либо на стандартный ввод процесса прослушивателя событий, пока этот процесс находится в состоянии **BUSY** или **ACKNOWLEDGED**. Супервизор начинает с отправки заголовка.

После обработки заголовка реализация прослушивателя событий должна считать байты **PAYLOAD\_LENGTH** из своего стандартного ввода, выполнить произвольное действие на основе значений в заголовке и данных, проанализированных из сериализации. При этом можно заблокировать на произвольное время. Supervisor продолжит обычную обработку, ожидая ответа, и по мере необходимости будет отправлять другие события того же типа другим процессам прослушивателя в том же пуле.

После того, как прослушиватель событий обработает сериализацию события, чтобы уведомить супервизор о результате, он должен отправить структуру результата на свой стандартный вывод. Структура результата — это слово `"RESULT"`, за которым следует пробел, за которым следует длина результата, за которым следует перевод строки, за которым следует содержимое результата. Например, `RESULT 2\nОК` — это результат «ОК». Обычно прослушиватель событий будет использовать либо **OK**, либо **FAIL** в качестве содержимого результата. Эти строки имеют особое значение для обработчика результатов по умолчанию.

Если обработчик результатов по умолчанию получает **OK** в качестве содержимого результата, он будет считать, что прослушиватель успешно обработал уведомление о событии. Если он получает **FAIL**, он предполагает, что прослушиватель не смог обработать событие, и событие будет повторно буферизовано и отправлено позже. Прослушиватель событий может отклонить событие по любой причине, вернув результат **FAIL**. Это не указывает на проблему с данными события или прослушивателем событий. Как только супервизор получает результат **OK** или **FAIL**, прослушиватель событий переходит в состояние **ACKNOWLEDGED**.

Как только прослушиватель находится в состоянии **ACKNOWLEDGED**, он может либо выйти (и впоследствии может быть перезапущен супервизором, если его параметр конфигурации **autorestart** равен **true**), либо продолжить работу. Если он продолжает работать, то для того, чтобы супервизор снова перевел его в состояние **READY**, он должен отправить токен **READY**, за которым сразу следует перевод строки, на стандартный вывод.

### Пример реализации прослушивателя событий

Реализация Python «длительного» прослушивателя событий, который принимает уведомление о событии, печатает заголовок и полезную нагрузку в свой **stderr** и отвечает результатом **OK**, а затем **READY**, выглядит следующим образом.

```python
import sys

def write_stdout(s):
    # только сообщения протокола eventlistener могут быть отправлены
    # на стандартный вывод
    sys.stdout.write(s)
    sys.stdout.flush()

def write_stderr(s):
    sys.stderr.write(s)
    sys.stderr.flush()

def main():
    while 1:
        # переход от ACKNOWLEDGED к READY
        write_stdout('READY\n')

        # читает строку заголовка и печатает ее в stderr
        line = sys.stdin.readline()
        write_stderr(line)

        # читает полезную нагрузку события и печатает ее в stderr
        headers = dict([ x.split(':') for x in line.split() ])
        data = sys.stdin.read(int(headers['len']))
        write_stderr(data)

        # переход от READY к ACKNOWLEDGED
        write_stdout('RESULT 2\nOK')

if __name__ == '__main__':
    main()
```

В пакете [Superlance](http://supervisord.org/glossary.html#term-Superlance) присутствуют другие примеры слушателей событий, в том числе тот, который может отслеживать подпроцессы супервизора и перезапускать процесс, если он использует «слишком много» памяти.

### Условия ошибки прослушивателя событий

Если процесс прослушивателя событий завершается во время передачи события на его стандартный ввод или если он прекращает работу до отправки структуры результата обратно в **supervisord**, считается, что событие не было обработано, и оно будет повторно буферизовано **supervisord** и отправлено позже.

Если прослушиватель событий отправляет на свой стандартный вывод данные, которые супервизор не распознает как подходящий ответ на основе состояния, в котором находится прослушиватель событий, прослушиватель событий будет переведен в состояние **UNKNOWN**, и ему больше не будут отправляться уведомления о событиях. Если в это время прослушиватель обрабатывал событие, оно будет повторно буферизовано и отправлено позже.

### Разное

Прослушиватели событий могут использовать интерфейс Supervisor XML-RPC для обратного вызова Supervisor. Таким образом, прослушиватели событий могут влиять на состояние подпроцесса Supervisor в результате получения уведомления о событии. Например, вы можете захотеть генерировать событие каждые несколько минут, связанное с использованием подпроцессов, контролируемых супервизором, и если какой-либо из этих процессов превышает некоторый порог памяти, вы хотели бы перезапустить его. Вы должны написать программу, которая заставит супервизор время от времени генерировать события **PROCESS\_COMMUNICATION** с информацией о памяти в них, а прослушиватель событий будет выполнять действие на основе обработки данных, которые он получает от этих событий.

## Типы событий
