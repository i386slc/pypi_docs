# Ведение журнала

Одной из основных задач, которую выполняет **supervisord**, является логирование. **supervisord** ведет журнал активности, подробно описывая, что он делает во время работы. Он также записывает вывод **stdout** и **stderr** дочернего процесса в другие файлы, если запись настроена для этого.

## Журнал активности

Журнал активности — это место, где **supervisord** регистрирует сообщения о своем собственном здоровье, изменениях состояния своего подпроцесса, любые сообщения, возникающие в результате событий, а также отладочные и информационные сообщения. Путь к журналу действий настраивается с помощью параметра **logfile** в разделе `[supervisord]` файла конфигурации, по умолчанию это `$CWD/supervisord.log`. Если значением этого параметра является специальная строка **syslog**, журнал действий будет перенаправлен в службу **syslog**, а не записан в файл. Пример трафика журнала активности показан в примере ниже. Некоторые строки были прерваны, чтобы лучше соответствовать экрану.

### Пример выходных данных журнала активности

```log
2007-09-08 14:43:22,886 DEBG 127.0.0.1:Medusa (V1.11) started at Sat Sep  8 14:43:22 2007
        Hostname: kingfish
        Port:9001
2007-09-08 14:43:22,961 INFO RPC interface 'supervisor' initialized
2007-09-08 14:43:22,961 CRIT Running without any HTTP authentication checking
2007-09-08 14:43:22,962 INFO supervisord started with pid 27347
2007-09-08 14:43:23,965 INFO spawned: 'listener_00' with pid 27349
2007-09-08 14:43:23,970 INFO spawned: 'eventgen' with pid 27350
2007-09-08 14:43:23,990 INFO spawned: 'grower' with pid 27351
2007-09-08 14:43:24,059 DEBG 'listener_00' stderr output:
 /Users/chrism/projects/supervisor/supervisor2/dev-sandbox/bin/python:
 can't open file '/Users/chrism/projects/supervisor/supervisor2/src/supervisor/scripts/osx_eventgen_listener.py':
 [Errno 2] No such file or directory
2007-09-08 14:43:24,060 DEBG fd 7 closed, stopped monitoring <PEventListenerDispatcher at 19910168 for
 <Subprocess at 18892960 with name listener_00 in state STARTING> (stdout)>
2007-09-08 14:43:24,060 INFO exited: listener_00 (exit status 2; not expected)
2007-09-08 14:43:24,061 DEBG received SIGCHLD indicating a child quit
```

Уровень `«level»` журнала активности настраивается в файле конфигурации с помощью параметра **loglevel** в разделе `[supervisord]` ini-файла. Когда установлен уровень журнала, сообщения указанного приоритета, а также сообщения с более высоким приоритетом регистрируются в журнале активности. Например, если **loglevel** равен **error**, будут регистрироваться сообщения об **error** и **critical**. Однако, если **loglevel** равен **warn**, в журнал будут записываться **warn**, **error** и сообщения **critical**.

### Уровни журнала активности

В приведенной ниже таблице более подробно описаны уровни ведения журнала, отсортированные от самого высокого приоритета к самому низкому. «Config File Value» — это строка, указанная для параметра **loglevel** в разделе `[supervisord]` файла конфигурации, а «Output Code» — это код, который отображается в выходных строках журнала активности.

<table><thead><tr><th width="180.33333333333331">Config File Value</th><th width="136">Output Code</th><th>Описание</th></tr></thead><tbody><tr><td>critical</td><td>CRIT</td><td>Сообщения, указывающие на состояние, требующее немедленного внимания пользователя, изменение состояния супервизора или ошибку в самом супервизоре.</td></tr><tr><td>error</td><td>ERRO</td><td>Сообщения, указывающие на потенциально игнорируемое состояние ошибки (например, невозможность очистки каталога журнала).</td></tr><tr><td>warn</td><td>WARN</td><td>Сообщения, указывающие на аномальное состояние, которое не является ошибкой.</td></tr><tr><td>info</td><td>INFO</td><td>Нормальный информационный вывод. Это уровень журнала по умолчанию, если ни один из них не настроен явно.</td></tr><tr><td>debug</td><td>DEBG</td><td>Сообщения, полезные для пользователей, пытающихся отладить конфигурацию процесса и поведение связи (выходные данные процесса, изменения состояния прослушивателя, уведомления о событиях).</td></tr><tr><td>trace</td><td>TRAC</td><td>Сообщения, полезные для разработчиков, пытающихся отладить подключаемые модули супервизора, а также информация о запросах и ответах HTTP и RPC.</td></tr><tr><td>blather</td><td>BLAT</td><td>Сообщения, полезные для разработчиков, пытающихся отладить сам супервизор.</td></tr></tbody></table>

### Ротация журнала активности

Журнал активности «ротируется» **supervisord** на основе комбинации параметров **logfile\_maxbytes** и **logfile\_backups** в разделе `[supervisord]` файла конфигурации. Когда журнал активности достигает **logfile\_maxbytes** байт, текущий файл журнала перемещается в файл резервной копии и создается новый файл журнала активности. В этом случае, если количество существующих файлов резервных копий больше или равно **logfile\_backups**, самый старый файл резервной копии удаляется, а файлы резервных копий переименовываются соответствующим образом. Если файл, в который производится запись, называется `supervisord.log`, то при превышении **logfile\_maxbytes** он закрывается и переименовывается в `supervisord.log.1`, а если существуют файлы `supervisord.log.1`, `supervisord.log.2` и т. д., то они переименован в `supervisord.log.2`, `supervisord.log.3` и т. д. соответственно. Если **logfile\_maxbytes** равен 0, файл журнала никогда не ротируется (и, следовательно, никогда не создаются резервные копии). Если **logfile\_backups** равен 0, резервные копии не сохраняются.

## Журналы дочерних процессов

Стандартный вывод **stdout** дочерних процессов, порожденных супервизором, по умолчанию фиксируется для повторного отображения пользователям **supervisorctl** и другим клиентам. Если в разделе `[program:x]`, `[fcgi-program:x]` или `[eventlistener:x]` файла конфигурации не выполняется никакая конкретная конфигурация, связанная с файлом журнала, верно следующее:

* **supervisord** запишет вывод **stdout** и **stderr** дочернего процесса во временные файлы. Каждый поток записывается в отдельный файл. Это известно как режим журнала **AUTO**.
* Файлы журналов **AUTO** именуются автоматически и помещаются в каталог, настроенный как **childlogdir** раздела `[supervisord]` файла конфигурации.
* Размер каждого файла журнала **AUTO** ограничен значением `{streamname}_logfile_maxbytes` раздела программы (где `{streamname}` — «stdout» или «stderr»). Когда он достигает этого числа, он ротируется (как и журнал действий) на основе файла `{streamname}_logfile_backups`.

Ключи конфигурации, влияющие на ведение журнала дочерних процессов в разделах `[program:x]` и `[fcgi-program:x]`, следующие:

`redirect_stderr`, `stdout_logfile`, `stdout_logfile_maxbytes`, `stdout_logfile_backups`, `stdout_capture_maxbytes`, `stdout_syslog`, `stderr_logfile`, `stderr_logfile_maxbytes`, `stderr_logfile_backups`, `stderr_capture_maxbytes` и `stderr_syslog`.

Разделы `[eventlistener:x]` не могут указывать `redirect_stderr`, `stdout_capture_maxbytes` или `stderr_capture_maxbytes`, но в остальном они принимают те же значения.

Ключи конфигурации, влияющие на ведение журнала дочерних процессов в разделе файла конфигурации `[supervisord]`, следующие: **childlogdir** и **nocleanup**.

### Режим захвата (capture mode)

Режим захвата — это расширенная функция Supervisor. Вам не нужно понимать режим захвата, если вы не хотите предпринимать действия на основе данных, проанализированных из вывода подпроцесса.

Если раздел `[program:x]` в файле конфигурации определяет ненулевой параметр **stdout\_capture\_maxbytes** или **stderr\_capture\_maxbytes**, каждый процесс, представленный разделом программы, может выдавать специальные токены в своем потоке **stdout** или **stderr** (соответственно), что фактически приведет к тому, что супервизор выдаст сообщение события **PROCESS\_COMMUNICATION** (описание событий см. в разделе <mark style="color:purple;">События</mark>).

Протокол связи процесса опирается на два тега, один из которых дает супервизору команду войти в «режим захвата» для потока, а другой — выход. Когда поток процесса входит в «режим захвата», данные, отправленные в поток, будут отправлены в отдельный буфер в памяти, «буфер захвата», который может содержать максимум байта **capture\_maxbytes**. В режиме захвата, когда длина буфера превышает объем **capture\_maxbytes** байт, самые ранние данные в буфере отбрасываются, чтобы освободить место для новых данных. Когда поток процесса выходит из режима захвата, супервизор генерирует подтип события **PROCESS\_COMMUNICATION**, который может быть перехвачен прослушивателями событий.

Тег для запуска «режима захвата» в потоке процесса: `<!--XSUPERVISOR:BEGIN-->`. Тег для выхода из режима захвата: `<!--XSUPERVISOR:END-->`. Данные между этими тегами могут быть произвольными и формируют полезную нагрузку события **PROCESS\_COMMUNICATION**. Например, если программа настроена с **stdout\_capture\_maxbytes** равным «1 МБ», и она выдает следующее в своем потоке **stdout**:

```xml
<!--XSUPERVISOR:BEGIN-->Hello!<!--XSUPERVISOR:END-->
```

В этом случае **supervisord** создаст событие **PROCESS\_COMMUNICATIONS\_STDOUT** с данными в полезной нагрузке «Hello!».

Пример скрипта (написанного на Python), который генерирует событие связи процесса, находится в каталоге **scripts** пакета супервизора с именем `sample_commevent.py`.

Вывод процессов, указанных как «прослушиватели событий» (разделы `[eventlistener:x]`), таким образом не обрабатывается. Выходные данные этих процессов не могут войти в режим захвата.
