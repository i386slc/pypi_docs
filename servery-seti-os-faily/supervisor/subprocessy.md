# Субпроцессы

Основная цель **supervisord** — создавать процессы и управлять ими на основе данных в его файле конфигурации. Это делается путем создания подпроцессов. Каждый подпроцесс, порожденный супервизором, управляется **supervisord** на протяжении всего своего жизненного цикла (**supervisord** является родительским процессом для каждого создаваемого им процесса). Когда дочерний процесс умирает, супервизор уведомляется о его смерти с помощью сигнала **SIGCHLD** и выполняет соответствующую операцию.

## Недемонизирование подпроцессов

Программы, предназначенные для выполнения под супервизором, не должны демонизировать себя. Вместо этого они должны работать на переднем плане. Они не должны отсоединяться от терминала, с которого запускаются.

Самый простой способ определить, будет ли программа работать на переднем плане, — запустить команду, которая вызывает программу из приглашения оболочки. Если он возвращает вам контроль над терминалом, но продолжает работать, он демонизирует себя, и это почти наверняка будет неправильным способом запуска его под супервизором. Вы хотите запустить команду, которая, по сути, требует от вас нажатия `Ctrl-C`, чтобы снова получить контроль над терминалом. Если он возвращает вам приглашение оболочки после его запуска без необходимости нажимать `Ctrl-C`, это бесполезно под супервизором. У всех программ есть параметры для запуска на переднем плане, но нет «стандартного способа» сделать это; вам нужно будет прочитать документацию для каждой программы.

Ниже приведены примеры файлов конфигурации, которые, как известно, запускают общие программы в «переднем плане» в режиме Supervisor.

### Примеры конфигураций программы

Вот несколько примеров конфигурации программы из «реального мира»:

### Apache 2.2.6

```ini
[program:apache2]
command=/path/to/httpd -c "ErrorLog /dev/stdout" -DFOREGROUND
redirect_stderr=true
```

### Два экземпляра Zope 2.X и один сервер ZEO

```ini
[program:zeo]
command=/path/to/runzeo
priority=1

[program:zope1]
command=/path/to/instance/home/bin/runzope
priority=2
redirect_stderr=true

[program:zope2]
command=/path/to/another/instance/home/bin/runzope
priority=2
redirect_stderr=true
```

### **Postgres 8.X**

```ini
[program:postgres]
command=/path/to/postmaster
; используем сигнал "быстрого" отключения SIGINT
stopsignal=INT
redirect_stderr=true
```

### **OpenLDAP slapd**

```ini
[program:slapd]
command=/path/to/slapd -f /path/to/slapd.conf -h ldap://0.0.0.0:8888
redirect_stderr=true
```

### Другие примеры

Другие примеры сценариев оболочки, которые можно использовать для запуска служб под **supervisord**, можно найти по адресу [http://thedjbway.b0llix.net/services.html](http://thedjbway.b0llix.net/services.html). Эти примеры на самом деле предназначены для **daemontools**, но предпосылка такая же для супервизора.

Другой набор рецептов запуска различных программ на переднем плане доступен по адресу [http://smarden.org/runit/runscripts.html](http://smarden.org/runit/runscripts.html).

## Программа pidproxy

Некоторые процессы (например, **mysqld**) игнорируют сигналы, посылаемые реальному процессу, порожденному **supervisord**. Вместо этого такие программы создают «специальный» поток/процесс, который отвечает за обработку сигналов. Это проблематично, потому что **supervisord** может убить только процесс, который сам создал. Если процесс, созданный **supervisord**, создает свои собственные дочерние процессы, **supervisord** не может их убить.

К счастью, программы такого типа обычно записывают «**pidfile**», который содержит «специальный» PID процесса и предназначен для чтения и использования для уничтожения процесса. В качестве обходного пути в этом случае специальная программа **pidproxy** может обрабатывать запуск таких процессов. Программа **pidproxy** представляет собой небольшую прокладку, которая запускает процесс и после получения сигнала отправляет сигнал на **pid**, указанный в **pidfile**. Пример записи программы конфигурации для программы с поддержкой **pidproxy** приведен ниже.

```ini
[program:mysql]
command=/path/to/pidproxy /path/to/pidfile /path/to/mysqld_safe
```

Программа **pidproxy** помещается в **$BINDIR** вашей конфигурации при установке супервизора (это «консольный скрипт»).

## Среда подпроцесса

Подпроцессы наследуют среду оболочки, используемой для запуска программы **supervisord**. Некоторые переменные среды будут установлены самим **supervisord** и в дочерней среде, в том числе **SUPERVISOR\_ENABLED** (флаг, указывающий, что процесс находится под управлением супервизора), **SUPERVISOR\_PROCESS\_NAME** (имя процесса, указанное в файле конфигурации для этого процесса) и **SUPERVISOR\_GROUP\_NAME** (файл конфигурации -указанное имя группы процессов для дочернего процесса).

Эти переменные среды могут быть переопределены в параметре конфигурации раздела `[supervisord]` с именем **environment** (применяется ко всем подпроцессам) или в параметре конфигурации среды за-  `[program:x]` (применяется только к подпроцессу, указанному в `[program:x]` раздел). Эти настройки «среды» являются аддитивными. Другими словами, среда каждого подпроцесса будет состоять из:

* Переменные среды, установленные в оболочке, используемые для запуска supervisord…
* … добавлено/переопределено …
* … переменные окружения, установленные в глобальном «окружении»
  * вариант конфига…
  * … добавлено/переопределено …
  * … переменные среды, зависящие от супервизора
    * (`SUPERVISOR_ENABLED`, `SUPERVISOR_PROCESS_NAME`, `SUPERVISOR_GROUP_NAME`) ..
  * … добавлено/переопределено …
  * … переменные окружения, установленные внутри процесса
    * опция конфигурации "environment".

Никакая оболочка не выполняется **supervisord**, когда он запускает подпроцесс, поэтому переменные среды, такие как **USER**, **PATH**, **HOME**, **SHELL**, **LOGNAME** и т. д., не изменяются по сравнению со значениями по умолчанию и не переназначаются иным образом. Это особенно важно учитывать, когда вы запускаете программу из **supervisord**, запущенного от имени пользователя **root** с разделом **user=** в конфигурации. В отличие от **cron**, **supervisord** не пытается угадать и переопределить «фундаментальные» переменные среды, такие как **USER**, **PATH**, **HOME** и **LOGNAME**, когда он выполняет **setuid** для пользователя, определенного в параметре конфигурации программы **user=**. Если вам нужно установить переменные среды для конкретной программы, которые в противном случае могли бы быть установлены вызовом оболочки для конкретного пользователя, вы должны сделать это явно в параметре конфигурации `[program:x]` **environment=**. Пример установки этих переменных среды показан ниже.

```ini
[program:apache2]
command=/home/chrism/bin/httpd -c "ErrorLog /dev/stdout" -DFOREGROUND
user=chrism
environment=HOME="/home/chrism",USER="chrism"
```

## Состояния процесса

Процесс, контролируемый **supervisord**, в любой момент времени может находиться в одном из следующих состояний. Вы можете увидеть эти имена состояний в различных элементах пользовательского интерфейса в клиентах.

### `STOPPED` (0)

Процесс был остановлен из-за запроса на остановку или никогда не запускался.

### `STARTING` (10)

Процесс запускается из-за запроса на запуск.

### `RUNNING` (20)

Процесс запущен.

### `BACKOFF` (30)

Процесс перешел в состояние **STARTING**, но впоследствии вышел слишком быстро (до времени, заданного в **startsecs**), чтобы перейти в состояние **RUNNING**.

### `STOPPING` (40)

Процесс останавливается из-за запроса на остановку.

### `EXITED` (100)

Процесс вышел из состояния **RUNNING** (ожидаемо или неожиданно).

### `FATAL` (200)

Не удалось успешно запустить процесс.

### `UNKNOWN` (1000)

Процесс находится в неизвестном состоянии (ошибка программирования **supervisord**).

Каждый процесс, запущенный под управлением супервизора, проходит через эти состояния в соответствии со следующим направленным графом.

<figure><img src="../../.gitbook/assets/subprocess-transitions.png" alt=""><figcaption><p>График перехода состояний подпроцесса</p></figcaption></figure>

Процесс находится в состоянии **STOPPED**, если он был остановлен административно или никогда не запускался.

Когда процесс автоматического перезапуска находится в состоянии **BACKOFF**, он будет автоматически перезапущен **supervisord**. Он будет переключаться между состояниями **STARTING** и **BACKOFF** до тех пор, пока не станет очевидным, что он не может быть запущен, поскольку количество попыток запуска превысило максимальное, после чего он перейдет в состояние **FATAL**.

{% hint style="info" %}
Повторные попытки будут занимать все больше времени в зависимости от количества последующих попыток, каждый раз добавляя одну секунду.

Таким образом, если вы установите `startretries=3`, **supervisord** будет ждать одну, две и затем три секунды между каждой попыткой перезапуска, всего **5** секунд.
{% endhint %}

Когда процесс находится в состоянии **EXCITED**, он автоматически перезапускается:

* никогда, если для его параметра **autorestart** установлено значение **false**.
* безусловно, если его параметр **autorestart** имеет значение **true**.
* условно, если для его параметра **autorestart** задано значение **unexpected**. Если он вышел с кодом выхода, который не соответствует одному из кодов выхода, определенных в параметре конфигурации **exitcodes** для процесса, он будет перезапущен.

Процесс автоматически переходит из **EXITED** в **RUNNING** в результате того, что он настроен на автоматический перезапуск условно или безоговорочно. Количество переходов между **RUNNING** и **EXITED** никак не ограничено: можно создать конфигурацию, бесконечно перезапускающую завершившийся процесс. Это фича, а не баг.

Автоматически перезапущенный процесс никогда не будет перезапущен автоматически, если он окажется в состоянии **FATAL** (его необходимо перезапустить из этого состояния вручную).

Процесс переходит в состояние **STOPPING** через административный запрос на остановку, а затем оказывается в состоянии **STOPPED**.

Процесс, который не может быть успешно остановлен, навсегда останется в состоянии **STOPPING**. Эта ситуация никогда не должна возникать во время нормальной работы, так как это означает, что процесс не ответил на последний сигнал **SIGKILL**, отправленный ему супервизором, что «невозможно» в UNIX.

Переходы состояний, которые **всегда** требуют действий пользователя для вызова, следующие:

`FATAL` -> `STARTING`

`RUNNING` -> `STOPPING`

Переходы между состояниями, которые **обычно, но не всегда**, требуют действия пользователя для вызова, с отмеченными исключениями:

`STOPPED` -> `STARTING` (за исключением запуска **supervisord**, если процесс настроен на автозапуск)

`EXITED` -> `STARTING` (кроме случаев, когда процесс настроен на автоматический перезапуск)

Все остальные переходы состояний управляются **supervisord** автоматически.
