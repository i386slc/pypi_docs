# Почему Click?

Существует так много библиотек для написания утилит командной строки. Почему существует **Click**?

На этот вопрос легко ответить: потому что не существует ни одной утилиты командной строки для Python, в которой были бы отмечены следующие поля:

* Лениво компонуется без ограничений.
* Поддерживает реализацию соглашений командной строки Unix/POSIX.
* Поддерживает загрузку значений из переменных среды из коробки.
* Поддержка запроса пользовательских значений.
* Является полностью вложенным и компонуемым.
* Поддерживает обработку файлов из коробки.
* Поставляется с полезными общими помощниками (получение размеров терминала, цветов ANSI, получение прямого ввода с клавиатуры, очистка экрана, поиск путей конфигурации, запуск приложений и редакторов и т. д.).

Есть много альтернатив **Click**; очевидными являются **optparse** и **argparse** из стандартной библиотеки. Посмотрите, не резонирует ли что-то еще с вами.

**Click** фактически реализует собственный анализ аргументов и не использует **optparse** или **argparse** в соответствии с поведением анализа **optparse**. Причина, по которой он не основан на **argparse**, заключается в том, что **argparse** не допускает надлежащего вложения команд по своей конструкции и имеет некоторые недостатки, когда речь идет об обработке аргументов, совместимой с POSIX.

**Click** разработан, чтобы быть забавным и настраиваемым, но не слишком гибким. Например, возможности настройки страниц справки ограничены. Это ограничение является преднамеренным, поскольку **Click** обещает, что несколько экземпляров **Click** будут продолжать функционировать должным образом, когда они связаны вместе.

Слишком большая настраиваемость нарушит это обещание.

**Click** был написан для поддержки экосистемы микрофреймворков [Flask](https://palletsprojects.com/p/flask/), потому что ни один инструмент не мог предоставить ей необходимую функциональность.

Чтобы понять, что такое **Click**, я настоятельно рекомендую просмотреть главу «[Сложные приложения](slozhnye-prilozheniya.md)».

### Почему не argparse?

**Click** внутренне основан на **optparse**, а не на **argparse**. Это деталь реализации, о которой пользователю не нужно беспокоиться. **Click** не основан на **argparse**, потому что некоторые его особенности затрудняют работу с произвольными интерфейсами командной строки:

* **argparse** имеет встроенное поведение, чтобы угадать, является ли что-то аргументом или опцией. Это становится проблемой при работе с неполными командными строками; поведение становится непредсказуемым без полного знания командной строки. Это идет вразрез с амбициями **Click** по отправке на субпарсеры.
* **argparse** не поддерживает отключение перемежающихся аргументов. Без этой функции невозможно безопасно реализовать вложенный синтаксический анализ **Click**.

### Почему не Docopt и т.п. ?

**Docopt** и многие подобные ему инструменты хороши тем, как они работают, но очень немногие из этих инструментов имеют дело с вложением команд и возможностью компоновки, как **Click**. Насколько известно разработчику, **Click** — это первая библиотека Python, целью которой является создание уровня компонуемости приложений, выходящего за рамки того, что поддерживает сама система.

**Docopt**, например, анализирует ваши страницы справки, а затем анализирует их в соответствии с этими правилами. Побочным эффектом этого является то, что **docopt** довольно жестко обрабатывает интерфейс командной строки. Преимущество **docopt** в том, что он дает вам полный контроль над страницей справки. Недостатком является то, что из-за этого он не может перестроить ваш вывод для текущей ширины терминала, и это затрудняет перевод. Кроме того, **docopt** ограничен базовым синтаксическим анализом. Он не обрабатывает отправку аргументов и вызов или типы обратного вызова. Это означает, что помимо основной страницы справки необходимо написать много кода для обработки результатов синтаксического анализа.

Однако больше всего это затрудняет компонуемость. Хотя **docopt** поддерживает диспетчеризацию подкоманд, он, например, напрямую не поддерживает какое-либо автоматическое перечисление подкоманд на основе того, что доступно, или не обеспечивает согласованной работы подкоманд.

Это хорошо, но это отличается от того, как **Click** хочет работать. **Click** стремится поддерживать полностью компонуемые пользовательские интерфейсы командной строки, делая следующее:

* **Click** не просто анализирует, но и отправляет в соответствующий код.
* **Click** имеет сильную концепцию контекста вызова, который позволяет подкомандам реагировать на данные родительской команды.
* **Click** имеет достоверную информацию, доступную для всех параметров и команд, поэтому он может создавать унифицированные страницы справки для полного интерфейса командной строки и помогать пользователю в преобразовании входных данных по мере необходимости.
* **Click** хорошо понимает, что такое типы, и может выдавать пользователю согласованные сообщения об ошибках, если что-то пойдет не так. Подкоманда, написанная другим разработчиком, не будет внезапно умирать с другим сообщением об ошибке, потому что она обрабатывается вручную.
* **Click** имеет достаточно метаинформации, доступной для всей его программы, чтобы со временем развиваться и улучшать взаимодействие с пользователем, не заставляя разработчиков корректировать свои программы. Например, если **Click** решит изменить форматирование страниц справки, все программы **Click** автоматически выиграют от этого.

Цель **Click** — создавать компонуемые системы. Принимая во внимание, что цель **docopt** — создать самые красивые интерфейсы командной строки, созданные вручную. Эти две цели тонким образом конфликтуют друг с другом. **Click** активно мешает людям реализовывать определенные шаблоны для достижения унифицированных интерфейсов командной строки. Например, у вас, как у разработчика, очень мало выбора при форматировании справочных страниц.

### Почему жестко запрограммированное поведение?

Другой вопрос заключается в том, почему **Click** отказывается от **optparse** и жестко прописывает определенное поведение вместо того, чтобы оставаться настраиваемым. Для этого есть несколько причин. Самый большой из них заключается в том, что слишком большая настраиваемость затрудняет достижение последовательного взаимодействия с командной строкой.

Лучшим примером этого является функция обратного вызова **optparse** (_callback_) для принятия произвольного количества аргументов. Из-за синтаксической неоднозначности в командной строке невозможно реализовать полностью вариативные аргументы. Всегда есть компромиссы, которые необходимо делать, и в случае **argparse** эти компромиссы были достаточно важными, так что система, подобная **Click**, даже не может быть реализована поверх нее.

В данном конкретном случае **Click** пытается придерживаться нескольких общепринятых парадигм построения интерфейсов командной строки, которые можно хорошо задокументировать и протестировать.

### Почему нет автокоррекции?

Возник вопрос, почему **Click** не исправляет параметры автоматически, учитывая, что даже **optparse** и **argparse** поддерживают автоматическое расширение длинных аргументов. Причина этого в том, что это ответственность за обратную совместимость. Если люди начнут полагаться на автоматически изменяемые параметры, а кто-то в будущем добавит новый параметр, скрипт может перестать работать. Такого рода проблемы трудно найти, поэтому **Click** не пытается творить магию в этом вопросе.

Однако такое поведение может быть реализовано на более высоком уровне для поддержки таких вещей, как явные псевдонимы. Дополнительные сведения см. в разделе [Псевдонимы команд](rasshirennye-shablony.md#psevdonimy-komand).
